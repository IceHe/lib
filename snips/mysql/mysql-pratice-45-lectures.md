# MySQL 实战 45 讲

References

- MySQL 实战 45 讲 - 极客时间 : https://time.geekbang.org/column/article/68319

## 01. 基础架构: 一条SQL查询语句是如何执行的?

MySQL 可以分为两部分

- **Server 层**
- **存储引擎层**

### Server 层

Server 层包括

- **连接器**
- **查询缓存**
- **分析器**
- **优化器**
- **执行器**

所有 **跨存储引擎的功能都在 Server 层实现**

- 涵盖 MySQL 的大多数核心服务功能 _( 包括上文提到的连接器到执行器 )_
- 以及所有的 **内置函数** ( 如日期、时间、数学和加密函数等 )
- 比如 **存储过程、触发器、视图** 等

![logic-architecture.png](_images/logic-architecture.png)

### 存储引擎

而 **存储引擎** 层负责 **数据的存储和提取**. 其架构模式是插件式的, 支持多个存储引擎 :

- **InnoDB**
- **MyISAM**
- **Memory**

现在 **InnoDB 是最常用的存储引擎**, 从 MySQL 5.5.5 版本开始成为了 **默认存储引擎**

- _执行 `create table` 建表时, 如果不指定引擎类型, 默认使用的就是 InnoDB_
- 也可以通过指定存储引擎的类型来选择别的引擎, 比如在 `create table` 语句中使用 `engine=memory`, 来指定使用内存引擎创建表
    - _不同存储引擎的表数据存取方式不同，支持的功能也不同_

### 连接器

第一步, 先连接到这个数据库上, 这时候接待你的就是连接器, 它负责

- 跟客户端建立连接
- 获取权限
- 维持和管理连接

连接命令一般写法

```bash
mysql -h$ip -P$port -u$user -p
```

一个用户成功建立连接后, 即使用管理员账号对这个用户的权限做了修改, 也不会影响已经存在连接的权限. 修改完成后，只有再新建的连接才会使用新的权限设置.

_( icehe : 所以想保证绝对不越权, 就得在修改权限设置后, 强制关闭相关用户现存的 DB 连接, 对吧? )_

连接完成后, 如果你没有后续的动作, 这个连接就处于空闲状态, 你可以在 `show processlist` 命令中看到它

文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。

客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。

但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。

怎么解决这个问题呢？你可以考虑以下两种方案。

1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
2. 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的（可能是估算值）



