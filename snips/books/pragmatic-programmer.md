# Pragmatic Programmer

References

- Book "The Pragmatic Programmer : your journey to mastery, 2nd Edition"
    - ZH Ver. :《 程序员修炼之道：通往务实的最高境界（第二版）》

## Index

第一版前言

- Tip 1 : 关注你的技艺
    - 如果你不关心怎么做好, 为什么还要花时间去开发软件呢?
- Tip 2 : 思考! 思考你的工作
    - 关掉辅助驾驶, 有自己掌控, 持续不断地评估所做的工作

章 1 : 务实的哲学

_1\. 人生是你的_

- Tip 3 : 你有权选择
    - **人生是自己的. 把握住人生, 让它如你所愿**
        - _工作内容无聊没有意思? 团队一团糟? "改变这个组织, 或者换一个组织"_
        - _担心自己掌握的技术过时? 安排时间学习看起来有趣的新技术_
            - _这是一种自我投资, **只有为此加班才是合理的**_
        - _不要期待事情自己变好, 而是考虑一下 : 自己行动起来_

_2\. 我的源码被猫吃了_

- Tip 4 : 提供选择, 别找借口
    - **提供选择而不是去找理由. 不要只说做不到; 解释一下都能做到些什么**

_3\. 软件的熵_

- Tip 5 : 不要放任破窗
    - 只要看到 不好的设计 / 错误的决策 / 糟糕的代码, 就赶紧去纠正

_4\. 石头做的汤和煮熟的青蛙_

- Tip 6 : 做推动变更的催化剂
    - 你无法强迫人们去改变, 但可以展示美好未来, 并帮助他们参与创造
- Tip 7 : 牢记全景
    - 不要过度沉浸于细枝末节, 一面觉察不到周围正在发生的事情

_5\. 够用即可的软件_

- Tip 8 : 将质量要求视为需求问题
    - 让用户参与对项目真实质量的确定

_6\. 知识组合_

- Tip 9 : **对知识组合做定期投资**
    - 养成学习的习惯
- Tip 10 : 批判性地分析你读到和听到东西
    - 不要受供应商、媒体炒作或教条的影响, 根据自身和项目的实际情况来分析信息

_7\. 交流!_

- Tip 11 : 英语就是另一门编程语言
    - 将英语是做一门编程语言. 写文档和变成一样要遵守 DRY 原则、ETC、自动化等
        - _让它看起来不错_
            - _想法很重要. 但听众还希望有个好看的包装_
            - _太多的开发人员 ( 包括他们的经理 ) 在编写书面文档时, 只关注内容, 我们认为这不对_
            - _随便一个厨师 ( 或者是美食频道的主持人 ) 都会告诉你, 仅仅是糟糕的外观就能回调你在厨房里埋头苦干几小时的成果_
        - _回应别人_
            - _当你问别人一个问题时, 如果他们不回答, 你会觉得他们不礼貌_
            - _那么当别人发电子邮件或备忘录给你, 问你一些信息, 请你做一些事情时, 你有多少次没有回应? 日常生活忙忙碌碌, 忘点事情太常见了_
            - _一定要记得回复邮件, 就算简单地度偶依据 "我稍后答复你" 都好_
            - _**随时知会别人, 能让人更容易原谅你偶然的疏忽**, 让人觉得你并没有忘记他们_
- Tip 12 : 说什么和怎么说同样重要
    - 如果无法有效交流, 任何伟大的想法都是没有意义的
- Tip 13 : 把文档嵌进去, 而不要拴在表面
    - 与代码隔离的文档, 很难保持正确并及时更新

章 2 : 务实的方法

_8\. 优秀设计的精髓_

- Tip 14 : 优秀的设计比糟糕的设计更容易变更
    - 适合使用者的事物, 都已经过良好设计. 对代码来说, 这意味着必须适应变化
    - _ETC 原则 : Easier To Change 更容易变更_
        - _它是一种价值观念, 不是一条规则_

_9\. DRY -- 邪恶的重复_

- Tip 15 : DRY -- 不要重复自己
    - 系统中的每一条知识, 都必须有单一且无歧义的权威陈述
        - _注释中的重复_
            - _不要用注释来解释代码做了什么, 因为这样的话, 变化的代码迟早会跟注释的解释不一致_
            - _将命名和排版做好即可, 注释只用来解释做什么/为什么. 如果需要了解细节, 源码里应有尽有!_
        - _数据中的重复_
            - _一个对象既有 start 也有 end 还有 length 字段, 这没必要! 因为 length 可以根据 start 和 end 计算出来_
            - _如果以后有性能要求, 必须缓存 length, 那时才这么做, 不必过早优化_
            - _经验 : **一个模块提供的所有服务都应该通过统一的约定来提供, 该约定不应表露出其内部实现是基于存储还是基于计算的**_
        - _表征的重复_
- Tip 16 : 让复用变得更容易
    - 只要复用方便, 人们就会去做. 创建一个支持复用的环境

_10\. 正交性_

- Tip 17 : 消除不相关事物之间的影响
    - 设计的组件, 需要自成一体、独立自主, 有单一的清晰定义的意图
        - _正交性 : 象征着 独立性 或 解耦性 ( 从几何学中借用来的术语 )_
            - _对于两个或多个事物, 其中一个的改变不影响其他任何一个, 则这些事物是正交的_
        - _测试正交性的方法 : 如果一个特别功能背后的需求发生显著改变, 有多少模块会受影响?_
        - _**不要依赖那些你无法控制的东西**_
        - _**当耦合是好的时, 我们称之为内聚**_

_11\. 可逆性_

- Tip 18 : 不设最终决定
    - 不要把决定刻在石头上, 而要将其视为写在沙滩上的东西, 时刻准备应变
- Tip 19 : 放弃追逐时尚
    - 尼尔·福特说过 : "昨日之最佳实践, 即明日之反模式." 要基于基本原则去选择架构, 而不应盲从于流行

_12\. 曳光弹_

- Tip 20 : **使用曳光弹找到目标**
    - 通过不断尝试并看清着弹点, 曳光弹可确保你最终击中目标
        - _曳光弹式开发 -- 在真是条件下针对 "移动目标" (多变的需求) 进行即时反馈_
            - _创建一个简单的工程, 加一行 "hello world!", 并确保其能编译和运行_
            - _然后, 我们再去找整个应用程序中不确定的部分, 添加上让他们跑起来的骨架_
        - _曳光弹式开发 的 **特点 -- 能跑起来**_

_13\. 原型与便签_

- Tip 21 : **用原型学习**
    - 制作原型旨在学习经验,其价值不在于过程中产生的代码, 而在于得到的教训
        - _汽车制造商可能会为一款新城的设计制造许多不同的 "原型"_
        - _每个原型都是为了测试一个特定的方面 -- 空气动力学、造型、结构特征等_
        - _原型开发 **特点 -- 不必制作真正 (能运行) 的东西**_
        - _原型开发 **目标 -- 找出有风险或不确定的因素**_
            - _原型的意义  : 为了学习经验 -- 不在于产生的代码, 而在于吸取的教训_
        - _如果发现自己处在不能放弃细节的环境中, 可能不是在 "制作原型", 而是进行 "曳光弹式开发"_
            - _可以忽略的细节 : 正确性 / 完整性 / 健壮性 / 格式_
        - _开始任何基于代码的原型开发前, 确保每个人都理解, 正在编写的是一次性代码_
            - _原型可能有着欺骗性的外表, 对哪些不知道这只是原型的人产生吸引力_
            - _必须非常清楚地表明改代码是用完即弃的, 它并不完整也不可能做到完整_
            - _( 明确目的, 别做多余的无用功 )_

_14\. 领域语言_

- Tip 22 : 靠近问题域编程
    - 用问题领域的语言来做设计和编程
        - _这里说的不是 "面向领域编程", 详情见原书_

_15\. 估算_

- Tip 23 : **通过估算来避免意外**
    - 开始之前做估算, 能提前发现潜在问题
        - _例如, 对内存/硬盘/带宽/耗时/项目排期的估算_
        - _计划评审技术 PERT -- Program Evaluation Review Techininque_
            - _每个 PERT 任务都有一个乐观的、一个最可能的、一个悲观的估算_
- Tip 24 : 根据代码不断迭代进度表
    - 利用实施过程中获得的经验来精细化项目的时间尺度

章 3 : 基础工具

_16\. 纯文本的威力_

- Tip 25 : 将知识用纯文本保存
    - 纯文本不会过时. 它能够让你的工作事半功倍, 并能简化调试和测试工作
        - _GUI 工具的好处在于 WYSIWYG -- What you see is what you get._
        - _GUI 工具的弱势在于 WYSIAYG -- What you see is all you get._

_17\. Shell 游戏_

- Tip 26 : **发挥 Shell 命令的威力**
    - 当图形化界面无法胜任时, 使用 Shell

_18\. 加强编辑能力_

- Tip 27 : 游刃有余地使用编辑器
    - 既然编辑器是至关重要的工具, 不妨了解一下如何用它更快更准确地实现需求

_19\. 版本控制_

- Tip 28 : 永远使用版本控制
    - 版本控制为你的工作创造了一个时间机器, 可以用它重返过去

_20\. 调试_

- Tip 29 : **去解决问题, 而不是责备**
    - Bug 到底来自你的失误还是别人的失误真的不重要 -- 它终究是你的问题, 需要你来修复
- Tip 30 : **不要恐慌**
    - 不管是对银河系搭车客, 还是对开发者来说, 都应这样
        - _不要在 "但那不可能发生" 的思路上浪费哪怕一个神经元, 因为很明显它会发生, 而且已经发生了!_
        - _注意不要短视, 不要仅仅去纠正你所看到的症状, 永远要去发掘问题的 **根本原因**_
- Tip 31 : **修代码前先让代码在测试中失败**
    - 在你修 Bug 前, 先创建一个聚焦于该 Bug 的测试
- Tip 32 : **读一下那些该死的出错信息**
    - 大多数异常都能告诉失败之物与失败之处. 如果足够幸运, 你甚至能得到具体的参数值
- Tip 33 : "select" 没出问题
    - **在操作系统或编译器中发现 Bug 非常罕见**, 甚至在第三方产品或库中也是如此. Bug 大多出现在应用程序中
        - _怀疑操作系统/编译器/第三方库/中间件/数据库有问题? 还不如怀疑自己的应用程序有问题…_
- Tip 34 : **不要假设, 要证明**
    - 在真实环境中证实你的假设 -- 要依赖真实的数据及边界条件
        - _除了 bugfix, 还需要 **确认为什么没有更早地发现这个错误?**_
            - _是否需要修改单元测试或其它测试, 以让这些测试能够捕获到它_

_21\. 文本处理_

- Tip 35 : 学习一门文本处理语言
    - 既然每天都要花大量的时间与文本打交道, 何不让计算机帮你分担一二?

_22\. 工程日记_

- _就是 工作日志/备忘录/想法速记/……_
- _好处_
    - _备忘录 : 比记忆可靠_
    - _TODO List : 保存与当前任务无关的内容, 继续专注手头上的事_
    - _反观诸己 : 作用像是橡皮鸭, 换旁观者的角度来观察自己, 反省_

章 4 : 务实的偏执

- Tip 36 : 你无法写出完美的软件
    - 软件不可能是完美的. 对于在所难免的错误, 要保护代码和用户免受其影响
        - _务实的程序员更进一步, 他们连自己也不相信_

_23\. 契约式设计 ( **DBC -- Design By Contract** )_

- Tip 37 : 通过契约进行设计
    - 代码是否不多不少刚好完成它宣称要做的事情, 可以使用契约加以校验和文档化
        - _Design By Contract_
            - _前置条件 : 一个例程永远不应该在前置条件被违反的时候被调用_
            - _后置条件 : 保证例程完成时世界的状态 ( 例如不允许无线循环 )_
            - _类的不变式 : 从调用者角度来看, 类会确保该条件始终为真_
        - _强调编写 "懒惰" 的代码 ( 相关 : 正交性 建议编写 "害羞" 的代码 )_
            - _开始之前, 对要接收的东西要求严格一点, 并且尽可能少地对回报做出承诺_
            - _如果你定的契约是可以接受任何东西, 并且承诺回报整个世界, 那么你就有很多代码要写_

_24\. 死掉的程序不会说谎_

- Tip 38 : 尽早崩溃
    - 彻底死掉的程序通常比有缺陷的程序造成的损害要小
        - _与其 try-catch 之后 ( 可能会记一下日志, 再包装成别的异常 ) 重新抛出, 可能不如直接让异常抛出来_
        - _"防御式编程是在浪费时间, 让它崩溃!"_

_25\. 断言式编程_

- Tip 39 : 使用断言去预防不可能的事情
    - 如果一件事情不可能发生, 那么就用断言来确保其的确不会发生. 断言在校验你的假设, 要使用断言在不确定的世界中将你的代码保护起来

_26\. 如何保持资源的平衡_

- Tip 40 : 有始有终
    - 只要有可能, 对资源进行分配的函数或对象就有责任去释放该资源
- Tip 41 : 在局部行动
    - 将易变的变量维持在一个范围内, 打开资源的过程要短暂且明显可见

_27\. 不要冲出前灯范围_

- Tip 42 : 小步前进 -- 由始至终
    - 永远小步前进, 不断检查反馈, 并且在推进前先做调整
        - _我们不是应该为将来的维护做设计吗? 没错, 不过要适可而止: **别超过你能看见的范围**_
        - _越是必须预测未来会怎样, 就越有可能犯错. 与其浪费精力为不确定的未来设计, 还不如将代码设计成可替换的_
        - _当你想要丢弃你的代码, 或将其换成更合适的时, 要让这一切无比容易, 这有助于提高内聚性、解耦和 DRY, 从而实现更好的总体设计_
- Tip 43 : 避免占卜
    - 只在你能看到的范围内做计划

章 5 : 宁弯不折

_28\. 解耦_

- Tip 44 : 解耦代码让改变更容易
    - 耦合使事物紧紧绑定在一起, 以至于很难只改变其中之一
        - _注意留心一些耦合的 "症状"_
            - _…… ( 没深刻感受的前两条略过 )_
            - _开发人员害怕修改代码, 因为他们不确定会造成什么影响_
            - _会议要求每个人都必须参加, 因为没有人能确定谁会受到变化的影响_
- Tip 45 : 只管命令不要询问 _( TDA : tell-don't-ask )_
    - 不要从对象中取出值, 在加以变换后再塞回去, 让对象自己来完成这些工作
        - _直接向 "服务" 要我们想要的_
        - _[得墨忒耳定律](https://zh.wikipedia.org/wiki/%E5%BE%97%E5%A2%A8%E5%BF%92%E8%80%B3%E5%AE%9A%E5%BE%8B) ( LoD - Law of Demeter ) :_
            - _亦被称作 "最少知识原则" ( Principle of Least Knowledge )_
            - _定义在 C 类中的方法只应该调用 :_
                - _C 类其它实例的方法_
                - _它的参数_
                - _他所创建出来的对象的方法, 包括在栈上和堆上的对象_
                - _~~全局变量~~_
- Tip 46 : 不要链式调用方法
    - 当访问某事物时, 使用的点号不要超过一个
        - _例外 : 如果你链式调用的东西真的不太可能改变_
        - _实践中, 应用程序中的任何内容, 都应该被认为是可能发生改变的_
- Tip 47 : 避免全局数据
    - 最好给每个方法增加一个额外的参数
        - _全局可访问数据是应用程序组件之间耦合的潜在来源_
            - _**每一块全局数据就好像让应用程序中的每个方法都突然获得了一个额外的参数**_
        - _全局变量带来耦合的最明显原因 : **可能会潜在地影响到系统中的所有代码**_
            - _当然, 在实践中影响相当有限; 问题在于你必须找到每一处需要修改的地方_
        - _**当然 "重用" 可能不总是创建代码时主要考虑的问题**; 但它仍然是一个可以探求的目标_
        - _全局数据包括外部资源 : DB / 数据存储 / File System / 服务 API_
            - _确保始终将这些资源包装在你所控制的代码之中_
- Tip 48 : 如果全局唯一非常重要, 那么将它包装到 API 中
    - …… 但是, 仅限于你真的非常希望它是全局的
        - _耦合的代码很难变更, 所以要避免一个地方的修改对其它地方产生副作用_
        - _**让代码害羞一点 : 让它只处理直接知道的事情**_

_29\. 在现实世界中抛球杂耍_

- _事件 : 响应事件的应用程序, 使用 4 种策略来帮助来避免紧密耦合_
    - _1\. 有限状态机 ( FSM - Finite State Machine )
        - _其实并不困难_
    - _2\. 观察者模式 ( Observer Pattern )_
        - _观察者根据其兴趣被注册到观察对象上, 这通常由传递一个带调用的函数引用来实现_
            - _当事件发生时, 被观察对象遍历它的观察者列表, 并调用每个传递给它的函数; 事件作为调用参数提供给函数_
        - _因为每个观察者都必须与被观察对象注册在一起, 所以引入了耦合_
        - _在经典的实现中, 回调是由被观察对象以同步的方式内联处理的, 因此可能造成性能瓶颈_
    - _3\. 发布/订阅 ( Pubsub - Publish / Subscribe )_
        - _推广了观察者模式, 同时解决了耦合和性能问题_
    - _4\. 响应式编程与流 ( Responsive Programming & Stream )_
        - _事件流 : 例如, 生成一个包含用户 ID 的被观察事件, 用它来取代那个被观察的对象_

_30\. 变换式编程_

- Tip 49 : 编程讲的是代码, 而程序谈的是数据
    - 所有的程序都在变换数据 -- 将输入转换为输出. 开始用变换式方法来设计吧!
        - _举例 : 列出目录树中拥有行数最多的 5 个文件_
            - _使用命令和管道来实现 `find . -type f | xargs wc -l | sort -n | tail -5`_
        - _除了命令行或编程语言中的管道特性, 还有 Java 的 Stream 等_
- Tip 50 : 不要国积状态, 传递下去
    - 不要把数据保持在函数或模块的内部, 拿出来传递下去
        - _详见原书程序例子_
            - _stream / pipe 的错误处理怎么做 : 在变换的内部或外部做_
        - _变换到 "变换式编程"_
            - _将代码看作一系列 (嵌套的) 变换, 可以为编程打开思路_
            - _这需要一段时间来适应, 但是一旦你养成这个习惯, 将发现代码变得更简洁, 函数变得更短, 而而删除也变得更平顺_

_31\. 继承税_

- Tip 51 : 不要付继承税
    - 考虑一下能更好满足需求的替代方案, 比如接口、委托或 mixin
- Tip 52 : 尽量用接口来表达多态
    - 无需继承引入的藕合, 接口就能明确描述多态性
- Tip 53 : 用委托提供服务 : "有一个" 胜过 "是一个"
    - 不要从服务中继承, 应该包含服务
- TIp 54 : 利用 mixin 共享功能
    - mixin 不必承担继承税就可以给类添加功能, 而与接口结合可以让多态不再令人痛苦

_32\. 配置_

- Tip 55 : 使用外部配置参数化应用程序
    - 如果代码对一些在应用程序发布后还有可能改变的值有所依赖, 那么就在应用外部维护这些值

章 6 : 并发

_33\. 打破时域耦合_

- Tip 56 : 通过分析工作流来提高并发性
    - 利用用户工作流中的并发性

_34\. 共享状态是不正确的状态_

- Tip 57 : 共享状态是不正确的状态
    - 共享状态会带来无穷的麻烦, 而且往往只有重启才能解决
- Tip 58 : 随机故障通常是并发问题
    - 或许时间和上下文的变化能暴露并发 Bug, 但并发 Bug 无法始终保持一致, 也很难重现

_35\. 角色与进程_

- Tip 59 : 用角色实现并发性时不必共享状态
    - 使用角色来管理并发状态, 可以避免显式的同步

_36\. 黑板_

- Tip 60 : 使用黑板来协调工作流
    - 使用黑板来协调不相关的事实和代理人, 能同时保持参与者之间的独立性和孤立性

章 7 : 当你编码时

_37\. 听从蜥蜴脑_

- Tip 61 : 倾听你内心的蜥蜴
    - 当编程举步维艰时, 其实是潜意识在告诉你有什么地方不对劲

_38\. 巧合式编程_

- Tip 62 : 不要依赖巧合编程
    - 只能依赖可靠的事物. 注意偶然事件的复杂性, 不要混淆快乐的巧合与有目的的计划

_39\. 算法速度_

- Tip 63 : 评估算法的级别
    - 在开始编程前, 对这件事情大概会花多长时间要有概念
- Tip 64 : 对估算做测试
    - 针对算法的数学分析无法说明所有问题, 尝试在目标环境中测试一下执行代码的耗时

_40\. 重构_

- Tip 65 : 尽早重构, 经常重构
    - 像除草和翻整花园那样, 只要有需要就对代码进行重新编写、修订和架构, 以便找到问题的根源并加以修复

_41\. 为编码测试_

- Tip 66 : 测试与找 Bug 无关
    - 测试是观察代码的一个视角, 可以从中得到针对设计、接口和耦合度的反馈
- Tip 67 : 测试是代码的第一个用户
    - 用测试的反馈来引导工作
- Tip 68 : 既非自上而下, 也不自下而上, 基于端对端构建
    - 创建一小块端到端的功能, 从中获悉问题之所在
- Tip 69 : 为测试做设计
    - 写下代码之前先从测试角度思考
- Tip 70 : 要对软件做测试, 否则只能留给用户去做
    - 无情地测试, 不要等用户来帮你找 Bug

_42\. 基于特性测试_

- Tip 71 : 使用基于特性的测试来校验假设
    - 基于特性的测试将会进行你从未想过的尝试, 并会以你不曾打算采用的方式操练你的代码.

_43\. 出门在外注意安全_

- Tip 72 : 保持代码简洁, 让攻击面最小
    - 复杂的代码给 Bug 以滋生之沃土, 给攻击者以可趁之机
- Tip 73 : 尽早打上安全补丁
    - 攻击者会尽可能快地部署攻击, 你必须快上加快

_44\. 事务命名_

- Tip 74 : 好好取名; 需要时更名
    - 用名字向读者表达你的意图, 并且在意图改变时及时更名

章 8 : 项目启动之前

_45\. 需求之坑_

- Tip 75 : 无人确切知道自己想要什么
    - 他们或许知道大概的方向, 但不会了解过程的曲折
- Tip 76 : 程序员帮助人们理解他们想要什么
    - 软件开发更像是一种由用户和程序员协同创造的行为
- Tip 77 : 需求是从反馈循环中学到的
    - 理解需求需要探索和反馈, 因此决策的结果可以用来完善最初的想法
- Tip 78 : 和用户一起工作以便从用户角度思考
    - 这是看透系统将如何被真正使用的最佳方法
- Tip 79 : 策略即元数据
    - 不要将策略硬编码进系统, 而应该将其表达为系统的一组元数据
- Tip 80 : 使用项目术语表
    - 为项目的所有特定词汇创建一张术语表, 并且在单一源头维护

_46\. 处理无法解决的难题_

- Tip 81 : 不要跳出框框思考 -- 找到框框
    - 在面对无法解决的难题时, 识别出真正的约束. 可以问自己 : "必须 这样做才能搞定吗? 必须搞定它吗?"

_47\. 携手共建_

- Tip 82 : 不要一个人埋头钻进代码中
    - 编程往往困难又费力, 找个朋友和你一起干
- Tip 83 : 敏捷不是一个名词; 敏捷有关你如何做事
    - 敏捷是一个形容词, 有关如何做事情

_48\. 敏捷的本质_

章 9 : 务实的项目

_49\. 务实的团队_

- Tip 84 : 维持小而稳定的团队
    - 团队应保持稳定、小巧, 团队中的每个人都应相互信任、互相依赖
- Tip 85 : 排上日程以待其成
    - 如果你不把事情纳入日程表, 它们就不会发生. 反思、实验、学习、提高技能, 这些事都应放入日程表
- Tip 86 : 组织全功能的团队
    - 围绕功能而不是工作职能组织团队. 不要将 UI/UX 设计者从程序员中分离出去, 也不要分开前端和后端; 不要区分数据建模者和测试人员, 以及开发和设计. 构建一个团队, 这样你就可以渐进地不断迭代端到端的代码

_50\. 椰子派不上用场_

- Tip 87 : 做能起作用的事, 别赶时髦
    - 不要仅仅因为别的公司正在那么干就采纳一项技术或采用一个开发方法, 而是要采用自己所处环境中对团队有效的东西
- Tip 88 : 在用户需要时交付
    - 不要卡着流程要求, 刻意等到几周甚至几个月后才交付

_51\. 务实的入门套件_

- Tip 89 : 使用版本控制来驱动构建、测试和发布
    - 利用提交或推送来触发构建、测试、发布, 利用版本控制的标签来进行生产部署
- Tip 90 : 尽早测试, 经常测试, 自动测试
    - 每次构建都跑一下的测试, 要比束之高阁的测试计划有效得多
- Tip 91 : 直到所有的测试都已运行, 编码才算完成
    - 无须多言
- Tip 92 : 使用破坏者检测你的测试
    - 在一个单独的源码副本中特意引入 Bug, 验证测试能否将其捕获
- Tip 93 : 测试状态覆盖率, 而非代码覆盖率
    - 要识别并测试重要的程序状态, 只测试一行行的代码是不够的
- Tip 94 : 每个 Bug 只找一次
    - 只要人类测试者找到一个 Bug, 就应该是该 Bug 最后一次被人类发现. 从此之后, 自动化测试完全可以发现它
- Tip 95 : 不要使用手动程序
    - 计算机能一次又一次, 按照同样的次序, 执行相同的指令

_52\. 取悦用户_

- Tip 96 : 取悦用户, 而不要只是交付代码
    - 为用户开发能够带来商业价值的解决方案, 并让他们每天都感到愉快
- Tip 97 : 在作品上签名
    - 过去的工匠在为他们的作品签名时非常自豪, 你也应该这样

_53\. 傲慢与偏见_

跋

- Tip 98 : 先勿伤害
    - 犯错在所难免, 确保犯错后没人会因此受难.
- Tip 99 : 不要助纣为虐
    - 因为这样做你也有变成封王的风险
