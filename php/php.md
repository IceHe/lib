title: PHP 编程经验
date: 2019-07-10
updated: 2019-07-10
noupdate: true
categories: [PHP]
tags: [PHP]
description: 写 PHP 代码的一些经验与感想。
---

## 引子

有太多的编程语言和工具，一旦不常使用，很容易就会遗忘其中一些需要重视的细节。所以，有必要去总结、固化自己掌握的相关知识经验。即使一时忘记了也不要紧，用自己的总结材料来复习，可以快速地「重拾」曾经掌握过的技能。

笔者水平有限，请谨慎参考本文。可以去 Google，甚至看源码。尽量自己动手写代码，来对具体的情况进行试验，因为文档可能会过时失效，记忆可能会模糊出错，只有用实践来检验真理才是最牢靠的。如发现本文的错误，烦请指正，感谢交流~

### 八卦：最好的语言？

{% cq %}
PHP 是世界上最好的（编程）语言！

__原始出处不详__
{% endcq %}

不少 PHP 的圈外人和新手不懂行，难免无法理解以至于误解这句流传甚广的话，甚至睥睨 PHP 并施以冷嘲热讽。

（如果一个程序员对计算机的技术和文化有足够的理解，应该耻于做这种「忽视场景，牵强对比各种编程语言优劣」的事来自找优越感。除非是一些特别的情况，可能他在「钓鱼」或者…… 见下文）

实际上「PHP 是世界上最好的语言」这句话已经成了一种梗，PHP 程序员经常以这种「自嘲」的方式表明身份。比如，我们也会戏称自己以「拍黄片」（Pai Huang Pian）为业。

- PHP 圈的八卦见闻：
    竟然有人嘲笑 PHP 的「继父」鸟哥 惠新宸（Laruence [@weibo](http://weibo.com/laruence)、[@GitHub](https://github.com/laruence)、[@Blog](http://www.laruence.com/)）竟然敢自称「亚洲第一程序员」（我真实碰过这么认为的朋友），其实这是一个以讹传讹的失实说法。鸟哥并没有这样自称，「亚一程」这只不过是中国 PHP 小圈子里的友人给他取得的一个绰号而已，是一个富于幽默感的戏称（爱称），也算是由「PHP 是最好的语言」引申出来的梗。毕竟鸟哥给 PHP 社区做出了如此巨大的贡献，旧的 PHP 项目只要换上 PHP7 的运行环境就能有惊人的性能提升（可另行搜索了解详情），然后当年的性能 KPI 就完成了…… 圈内用这样饶有趣味地方式来捧鸟哥，实在是再正常不过的事，哈哈。PHP7 出来已经挺久，现在也不常有人提起「亚一程」这个梗了。

### PHP 的一些槽点

但是不得不承认，PHP 在诞生之初，由于一些缺乏远见的初始设计，导致了它有着一些难以修正的缺陷，但无伤大雅。在完美主义者的眼里，PHP 确实写起来不够「优雅」。为了兼容性，即使是焕然一新的新版本 PHP7，也无法抛弃全部的历史包袱。这里提其中一些槽点：

1. __美元符 `$`__ 通常放在变量名前面，用于声明和使用变量，有人光是看到 `$` 美元符就会觉得特不爽。
2. 内建函数的 __函数名__ 风格不一致、或长或短，其中一些函数明显带有 C 语言的风格特征，其实就和 C 语言的库函数同名，然而后来新增的一些内建函数的名字却又比较完整比较长……
3. 不少函数的 __函数参数__ 的排列规律不够一致（可准确预测），如果不常用、又不去参考手册（[PHP.net](http://php.net/)），我会担心自己搞错它们含义、用途和排列顺序。
    - 官方网站 [PHP.net](http://php.net/) 也是一个奇特的存在，它是存放参考文档的网页，也像一个论坛或问答区（官网并没有直接提供社区）。参考页面下可以盖楼「评论」，你可以对评论「顶」或「踩」，许多评论会提供相关的使用样例、测试代码和更深入的细节说明，可能比文档正文还管用……
4. __函数的返回值__，跟 C 语言一样，它的返回值并不一致。
    - 例如，C 语言的一些关于字符数组的库函数，它们的返回类型是 int，因为 C 不可能依靠抛出异常来表示错误，只能给 int -1 这种值额外赋予特殊的含义，即发生错误，所以表达上并不够清晰和一致（其实这并无大碍，毕竟它是比较接近硬件的机器码，不可能也没必要封装异常这种「高级特性」）。
    - PHP 是一种弱类型的语言，虽然也有「类」和「异常」，但是使用一些内建函数也并不抛出异常。例如 `strpos()`，它会返回字符串中的某种子字符串的出现位置，这个位置由非负的整数来表示，如果找不到就会返回布尔类型的 `false`。
    - 这时如果要判断「某个子字符串没在一个字符串里出现」就得用表达式：
        `false !== strpos('字符串', '子字符串')`。
        - 基础说明：`!==` 是「不全等于」的比较操作符，比较的两个变量的数值及其类型要同时不一样时，表达式的结果才是 `true`；`!=` 是「不等于」的比较操作符，只要比较的两个变量的数值相等，表达式结果就是 `true`，如果它们的数值类型不同，就会对变量进行隐式的类型转换，然后再进行比较。正是因为弱类型语言的这一「隐式类型转换」的过程，许多对编程语言不熟悉、逻辑又不严谨的程序员，写出了 bug 频出的 PHP 代码。
        - 如果这时误用了逻辑表达式 `false != strpos('字符串', '子字符串')` 来判断可就麻烦了：
            子字符串出现在字符串的开头，`strpos()` 会返回整数 `0`，
            然后 `0` 会转换成 `boolean` 布尔类型，值为 `false`，最终表达式同样也会返回 `true`，然而这是错误的判断结果。它跟 C 语言中的 `strpos()` 有着「异曲同工之错」，容易被不熟练的人误用。
5. __弱类型变量的比较__，详见上一段。「隐式类型转换」是弱类型编程语言的特点，是优点也是缺点 —— 容易上手，但更容易用错。在后文的「逻辑表达式」小节，会有更进一步的细节讨论。
6. 其它暂略……

__知乎问答[「PHP既然这么烂，那它是怎么火起来的？」PHP7 核心开发者 惠新宸 Laruence 的回答](https://www.zhihu.com/question/28596521/answer/49125835)__ 值得一看。

<!--### 共同之处-->

<!--[`PHP` `Python` `JavaScript` `Java` `C++` `C` `ASM`](/about/#技术)，我还算胜任其中一两种编程语言，简单了解并能通过搜索引擎和参考文档简单地使用其余语言，但是完全不敢说「熟悉」甚至「精通」一种语言。毕竟编程语言的底层实现和用法细节，即使深入理解过，一旦不用就会荒废。-->

<!--先把一门编程语言学精，再学第二门言语就会容易得多了。学多了之后，多少能感觉到它们之间的共通之处。它们毕竟只是达成某种目的而存在的手段、工具，在不同的实践场景之下，各有优劣。-->

### TODO

<http://php.net/manual/en/language.operators.php>

操作符的优先级
老生常谈，我们必须要多加括号 () 以便阅读，一眼看出问题

PHP7

PHP-FPM

Ngnix | Apache

官方文档 PHP.net

框架 Yaf Yii Zend Laravel Lumen

包管理器 composer
    … install
    … dump
    … update
    过程的 -vvv 详细输出
    composer.lock
    composer.json
    镜像
    https 下载

phpunit
单元测试

phpmd & phpcs
代码风格检查

Redis & memcache
缓存

MySQL
存储

PHP - The Right Way
清单

### 类型判断

# 说明

* 本文 `$v` 代表一般的变量，`$vs` 代表数组，`$vs[$k]` 代表通过下标访问数组

* `$oo ? $oo : $xx` === `$oo ?: $xx`

	注意：`$a ?: $b` !== `$a ?? $b`

	而且 `$a[$k] ?: $b` !== `$a[$k] ?? $b`

* `empty($v) === !$v`

	注意：使用下标访问时，即使用 `$vs[$k]` 时，

	`empty($vs[$k]) !== !$vs[$k]`

	所以，`empty($a) ? $b : $a` === `$a ? $a : $b` === `$a ?: $b`

* 当 `$v` 为 `0`, `''`, `'0'`, `[]`, `null`, `false` 时，

	false === `empty($v)` === `!$v`

* `empty($vs[$k])` 已经包含了 `isset($vs[$k])` 的判断，

	所以，当 `$vs[$k]` 不存在时，使用 `empty($vs[$k])` 不会出现数组下标访问的错误

* 当 `$params = Request::only('a', 'b');` 时，

	如果 `Request::all()` 中不存在 a 参数，`$params['a'] === null`

## 常用函数

报错全开！
报错全关才能正常运行，这样的项目是不合理的。

isset
empty
!
!!
??
?:
&&
||
下标访问

## 有用的代码封装

字符串工具 'strpos(...) ===(!==) false' with '(!)str_contains(...)'
str_contains
starts_with
ends_with

数组工具（点操作符访问）
array_get
array_has
array_flat
array_pluck

reset

## 编程风格

类型隐式转换
最严重的一个问题，造成各种逻辑错误。

设计模式
单例模式
工厂模式
反射的问题 __call：IDE 无法做类型推导，除非单步调试，否则无法预知会跳转到哪 -> 结构性开销。
过度封装的学习成本

中间变量
方便调试
语意清晰
虽然为了更简短的代码，我通常不这么做，但是我认为这样是正确的

函数参数
传一个数组，还是传很多参数？

全局变量
过度的蔓延，用一层传一层？
值传递，导致中间环节某个不严谨的程序员对修改它的值

传引用
导致不可预知的错误

逻辑分支
if else
    必加尖括号 {}
用 expr && assign 或 expr || assign 这些费解的方式写条件语句？！
    不利于单元测试和变量追踪

全等于和等于，不等于和全不等于
    == != === !==
    布尔计算

控制流
尽量少分支
优先处理错误（比较短的分支，比较快就返回、退出）
使用 ?: 减少 if else
函数出口，最好是默认的情况

过度防卫
没有必要，有错就该退出
过度的兼容和检查，使代码过于冗余，难以看懂，反而造成更多错误

单步调试
xdebug
gdb（这个不懂，但是要提。最好试着使用一下）

代码同步
rsync
nc

运行环境
docker
service
重启 nginx 和 php-fpm
nginx 和 php-fpm 的配置文件
端口占用
php.ini
    php -i | grep 或 php --hi？
第三方组件
    xdebug
    安装
        pecl
        brew
    配置

IDE 的选择

编程风格
PSR
数组元素的对齐方式
    IDE 当然有自动格式化的功能，但是要照顾一般的代码编辑器、Vim、Emacs 等，自动对齐不一定有必要，反而增加了麻烦。
过长的代码行
一行只做一件事
    当人可以处理更高复杂性时，真的更容易倾向于写「聪明」的代码。
数组最后一个元素后面带 `,`
单引号和双引号！
    用 "o{$x}o" 还是 'o'.$x.'o'；还有写不写其中的 {}
    和 C++ 写法的对比！（静态语言和动态语言对字符串变量的处理）
变量命名问题
    复数 list or -s
    缩写问题

PHP7 函参的类型说明
一定程度上，帮助了类型检测，不需要你自己进行类型判断 instanceof，更方便发现并抛出错误！

PHP
本身已经能算是一种框架了，针对 Web 开发，已经拥有了相当高层级的封装，和便捷设置
    _SERVER _GET _POST _GLOBAL 等等全局变量
    require or include

最佳实践！
入门最好最快的方法
毕竟只是工具，没必要自己重新走弯路，在巨人的肩膀上前进。

PhpStorm 力荐，但贵
类型推导，功能内置
local history 本地历史
重构功能
正则替换

## 其它

看过不少编码规范，还有相关文章和书籍等等。可是看得再多也没有用，知识要内化变成习惯，才算是自己的。所以在这里一次性地快速写出自己的见解，用以检验自己通过日常的工作，到底消化了多少知识，积累了多少经验。

本文会持续更新，随时补充新的经验和感想，通过不断的记录、总结、反刍，加深理解和记忆，形成好的编程习惯，沉淀出一套适合自己、行之有效的做法。

因为是快速一次写成的，可能我举的例子有点烂，不过先表达清楚我想要表达的东西就好了。

## 清晰的逻辑分支

王垠的《[编程的智慧](http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy)》（第一遍写本博文，先不详细分析该文，先提印象最深的启发）让我重新思考这样的一个问题「怎样才算是逻辑清晰的代码？」

先给示例代码，来说明我想讨论的具体情境。写法一：

``` Python
def test(isA, isB):
    if isA:
        return 'App'

    if isB:
        return 'Boy'

    return false
```

以上代码写成完全的 if … elif … else 的方式应该是写法二：

``` Python
def test(isA, isB):
    if isA:
        return 'App'
    elif isB:
        return 'Boy'
    else:
        return false
```

大多数人包括我，都会采用第一种讨巧的写法，因为可以少输入一些字符，然而还是可以一下子看懂。当然当函数的代码变长，分支变多，嵌套加深，就没那么好看懂了。

但毫无疑问，显然第二种方式的逻辑分支之间的关系是最清晰的。对于写惯代码的人来说，第二种写法就显得有点笨了，因为他们基本都能处理更高的复杂度，一眼就能看懂低复杂度的代码。我理性倾向第二种写法，但实际写代码时却往往用第一种。那么问题来了，你觉得该用哪一种写法？

看一看更复杂的例子，写法一「完全展开的分支」：

``` Python
def test(isA, isB):
    if isA:
        if isB:
            if isT:
                return 'Tina'
            else:
                return 'ABTest'
        else:
            return 'App'
    else:
        if isB:
            if isT:
                return 'Tina'
            else:
                return 'Boy'
        else:
            return false
```

写法二：

``` Python
def test(isA, isB, isT):
    if not isA and not isB: # 守卫原则的代码写法
        return false

    if isT and not isA:
        return 'Tina'

    if isA and isB:
        return 'ABTest'
    elif isA:
        return 'App'
    else:
        return 'Boy'
```

## 清晰的逻辑

### 分支树、逻辑判断

王垠的 if else 全写策略！

不要写出过度让人费解的代码。
当然当你熟练之后，对一些复杂性有了深入的了解之后，就会下意识写出你能够理解的简短代码。
当然还是要避免过度的复杂。

## 过度防卫的原则

（该跑出错误，反映错误，就直接退出报错，不能容忍。有些需要兼容错误才做兼容！）

## 守卫原则

清晰易懂
if 后也把 else 写了，控制流程更清晰！（王垠的博文）

## 命名

英语太烂，还懒
缩写不统一

## 复制粘贴

## 中间变量

## 包装函数

## 注释

## IDE

### 类型推导

### 重构

减少机械重复的操作

### 搜索

### Live Template

就好像 Emmet 那样。
还有 auto complete

## 常用函数

## 参考文档

## 感受

### 堆代码写接口

「工作无价值」的迷思 —— 不要写得太烂就可以，你随便都可以被新来的人代替。

大公司打工悖论，不要把自己看得太高，你就是螺丝钉，随时都能被替换掉，这样公司的风险才小，才够稳定。
分工也相对提高了效率。

### 底层

高大上的迷思 —— 大公司、复杂业务，就没有干干净的代码。

### 没空学

自己作死而已。学会取舍，人生苦短，找准方向。

学习是靠自己，靠学校、老师，靠公司、Boss、业务，都是天真的。

自己不努力没别人能够帮助你。你也要自己努力一把，别人才会去帮助你 —— 问问题之前，请自己先 Google 一下，好好先折腾一番。

### 枯燥重复的编码

做算法题，都比这个有趣。
能够忍受重复无趣不是个优点，反而是累赘，让自己更加深陷其中「温水煮青蛙」。

有危机意识的不甘的人，反而更早跳出陷阱。

详见，后来在 Test 文件夹写出的好脚本！

### 学会很多语言？

## 正则表达式

方便做重构

### 还有 Macro 宏

批量化重复的机械性操作。

## Vim 的操作

少记很多 IDE 或代码编辑器的快捷键。

null
''
'true'
'false'
'null'
'-1'
'0'
'1'
'2'
false
true
[]
-1
0
1
2

isset
empty
is_null
is_string
is_array
!
is_numeric
is_object
is_bool
