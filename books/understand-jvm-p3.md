# Execution Engine

> Understanding Java Virtual Machine - Part 3

References

- Book《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》
    - 英文书名 : Understanding the Java Virtual Machine - Advanced Features and Best Practices, Third Edition
    <!-- - 垃圾回收算法手册: 自动内存管理的艺术 -->
    <!-- - Java 性能优化权威指南 / Effective Java -->

## 类文件结构

- 代码编译的结果从本地机器码转变为字节码
    - _是存储格式发展的一小步, 却是编程语言发展的一大步_

### 无关性的基石

- 实现语言无关性的基础仍然是 **虚拟机** 和 **字节码存储格式**
    - **JVM** 不与包括 Java 语言在内的任何程序语言绑定, 它 **只与 "Class文件" 这种特定的二进制文件格式所关联**
    - Class 文件中 **包含了 JVM 指令集、符号表以及若干其他辅助信息**
- _基于安全方面的考虑,《Java 虚拟机规范》中要求在 Class 文件必须应用许多强制性的语法和结构化约束_
    - 但 **图灵完备的字节码格式, 保证了任意一门功能性语言都可以表示为一个能被 JVM 所接受的有效的 Class 文件**
    - _作为一个通用的、与机器无关的执行平台, 任何其他语言的实现者都可以将 JVM 作为他们语言的运行基础, 以 Class 文件作为他们产品的交付媒介_
    - _例如, 使用 Java 编译器可以把 Java 代码编译为存储字节码的 Class 文件, 使用JRuby 等其他语言的编译器一样可以把它们的源程序代码编译成 Class 文件_
- 虚拟机丝毫不关心 Class 的来源是什么语言, 它与程序语言之间的关系如下图所示
    - Java 语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达
    - 这决定了字节码指令所能提供的语言描述能力必须比 Java 语言本身更加强大才行
    - _因此, 有一些 Java 语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来_
    - _这为其他程序语言实现一些有别于 Java 的语言特性提供了发挥空间_

![jvm-language-independency.png](_images/understand-jvm/jvm-language-independency.png)

### Class 类文件的结构

- Java 技术能够一直保持着非常良好的向后兼容性, Class 文件结构的稳定功不可没
    - _任何一门程序语言能够获得商业上的成功, 都不可能去做升级版本后, 旧版本编译的产品就不再能够运行这种事情_
- _本章所讲述的_ 关于 Class 文件结构的内容, 绝大部分都是在第一版的《Java虚拟机规范》( 1997 年发布, 对应于 JDK 1.2 时代的 JVM ) 中就已经定义好的
    - _内容虽然古老，但时至今日，Java 发展经历了十余个大版本、无数小更新, 那时定义的_ Class 文件格式的各项细节几乎没有出现任何改变
    - _尽管不同版本的《Java虚拟机规范》对 Class 文件格式进行了几次更新, 但基本上_ 只是在原有结构基础上新增内容、扩充功能, 并未对已定义的内容做出修改
- **Class 文件是一组以 8 Bytes 为基础单位的二进制流**
    - 各个数据项目严格按照顺序紧凑地排列在文件之中, 中间没有添加任何分隔符
        - _这使得整个 Class 文件中存储的内容几乎全部是程序运行的必要数据, 没有空隙存在_
    - **当遇到需要占用 8 Bytes 以上空间的数据项时, 则会按照高位在前的方式, 分割成若干个 8 Bytes 进行存储**
- _根据《Java虚拟机规范》的规定,_ **Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据, 这种伪结构中只有两种数据类型 : "无符号数" 和 "表"**
    - **无符号数** : **基本的数据类型**
        - 以 **u1 、u2 、u4、u8** 来分别代表 1 Byte、2 Bytes、4 Bytes 和 8 Bytes 的无符号数
        - 可以用来 **描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值**
    - **表** : 由多个无符号数或者其他表作为数据项构成的 **复合数据类型**
        - 为了便于区分, **所有表的命名都习惯性地以 "info" 结尾**
        - 用于 **描述有层次关系的复合结构的数据**, 整个 Class 文件本质上也可以视作是一张表
        - 这张 "表" 由下表所示的数据项按严格顺序排列构成

|类型|名称|数量|
|-|-|-|
|u4|magic|1|
|u2|minor_version|1|
|u2|major_version|1|
|u2|constant_pool_count|1|
|cp_info|constant_pool|constant_pool_count - 1|
|u2|access_flags|1|
|u2|this_class|1|
|u2|super_class|1|
|u2|interfaces_count|1|
|u2|interfaces|interfaces_count|
|u2|fields_count|1|
|field_info|fields|fields_count|
|u2|methods_count|1|
|method_info|methods|methods_count|
|u2|attributes_count|1
|attribute_info|attributes|attributes_count|

- 无论是 "无符号数" 还是 "表", **当需要描述同一类型但数量不定的多个数据时, 经常会使用一个前置的容量计数器加若干个连续的数据项的形式**
    - 这时候称这一系列连续的某一类型的数据为某一类型的 "集合"
- Class 的结构不像 XML 等描述语言
    - 由于它没有任何分隔符号, 所以在上表中的数据项，无论是顺序还是数量，甚至于数据存储的字节序 ( Byte Ordering, Class 文件中字节序为 Big-Endian ) 这样的细节, 都是被严格限定的
    - 哪个字节代表什么含义, 长度是多少, 先后顺序如何, 全部都不允许改变
- _接下来, 将要看这个表中各个数据项的具体含义_

### 魔数与 Class 文件的版本

- 每个 Class 文件的头 4 个字节被称为 **Magic Number** ( 魔数 )
    - 它的 **唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件**
- 不仅是 Class 文件, 很多文件格式标准中都有使用魔数来进行身份识别的习惯
    - _例如图片格式, GIF 或者 JPEG 等在文件头中都存有魔数_
- **使用魔数而不是扩展名来进行识别主要是基于安全考虑**
    - **因为文件扩展名可以随意改动**
    - 文件格式的制定者可以自由地选择魔数值, 只要这个魔数值还没有被广泛采用过而且不会引起混淆
- Class 文件的魔数的值为 `0xCAFEBABE`
    - _据 Java 开发小组最初的关键成员 Patrick Naughton 所说 : "我们一直在寻找一些好玩的、容易记忆的东西, 选择 0xCAFEBABE 是因为它象征着著名咖啡品牌 Peets Coffee 深受欢迎的 Baristas 咖啡"_
- 紧接着魔数的 4 个字节存储的是 Class 文件的版本号
    - 第 5 和第 6 个字节是次版本号 ( Minor Version )
    - 第 7 和第 8 个字节是主版本号 ( Major Version )
- **Java 的版本号是从 45 开始的, JDK 1.1 之后 的每个 JDK 大版本发布主版本号向上加 1**
    - _高版本的 JDK 能向下兼容以前版本的 Class 文件, 但不能运行以后版本的 Class 文件_
    - _因为《Java虚拟机规范》在 Class 文件校验部分明确要求了即使文件格式并未发生任何变化, 虚拟机也必须拒绝执行超过其版本号的 Class 文件_
    - 目前最新的 JDK 版本为 14, 可生成的 Class 文件主版本号最大值为 58.0

```bash
# on macOS
$ xxd HsdIsTest.class
00000000: cafe babe 0000 003a 001c 0a00 0200 0307  .......:........
00000010: 0004 0c00 0500 0601 0010 6a61 7661 2f6c  ..........java/l
00000020: 616e 672f 4f62 6a65 6374 0100 063c 696e  ang/Object...<in
00000030: 6974 3e01 0003 2829 5609 0008 0009 0700  it>...()V.......
00000040: 0a0c 000b 000c 0100 0948 7364 6973 5465  .........HsdisTe
00000050: 7374 0100 0161 0100 0149 0900 0800 0e0c  st...a...I......
00000060: 000f 000c 0100 0162 0a00 0800 030a 0008  .......b........
00000070: 0012 0c00 1300 1401 0003 7375 6d01 0004  ..........sum...
00000080: 2849 2949 0100 0443 6f64 6501 000f 4c69  (I)I...Code...Li
00000090: 6e65 4e75 6d62 6572 5461 626c 6501 0004  neNumberTable...
000000a0: 6d61 696e 0100 1628 5b4c 6a61 7661 2f6c  main...([Ljava/l
000000b0: 616e 672f 5374 7269 6e67 3b29 5601 0008  ang/String;)V...
000000c0: 3c63 6c69 6e69 743e 0100 0a53 6f75 7263  <clinit>...Sourc
000000d0: 6546 696c 6501 000e 4873 6469 7354 6573  eFile...HsdisTes
000000e0: 742e 6a61 7661 0021 0008 0002 0000 0002  t.java.!........
000000f0: 0000 000b 000c 0000 0008 000f 000c 0000  ................
00000100: 0004 0001 0005 0006 0001 0015 0000 0026  ...............&
00000110: 0002 0001 0000 000a 2ab7 0001 2a04 b500  ........*...*...
00000120: 07b1 0000 0001 0016 0000 000a 0002 0000  ................
00000130: 0005 0004 0006 0001 0013 0014 0001 0015  ................
00000140: 0000 0023 0002 0002 0000 000b 2ab4 0007  ...#........*...
00000150: b200 0d60 1b60 ac00 0000 0100 1600 0000  ...`.`..........
00000160: 0600 0100 0000 0a00 0900 1700 1800 0100  ................
00000170: 1500 0000 2900 0200 0100 0000 0dbb 0008  ....)...........
00000180: 59b7 0010 06b6 0011 57b1 0000 0001 0016  Y.......W.......
00000190: 0000 000a 0002 0000 000e 000c 000f 0008  ................
000001a0: 0019 0006 0001 0015 0000 001d 0001 0000  ................
000001b0: 0000 0005 05b3 000d b100 0000 0100 1600  ................
000001c0: 0000 0600 0100 0000 0700 0100 1a00 0000  ................
000001d0: 0200 1b
```

## 虚拟机类加载机制

## 虚拟机字节码执行引擎

## 类加载及执行子系统的案例和实战
