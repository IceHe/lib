title: Refactor - Note
---

注意：

别一边添加新功能，一边重构，
一次只做其中一件事！

一、好处：

1 改进软件设计
保持代码可读性，易于看懂其设计，
从而方便改进软件设计，
去除重复代码

2 使软件更易于理解
代码趋于简洁，
可以便于看到更深远的设计问题。

3 帮助找到bug

4 提高编程效率

二、何时重构：

1 三次法则：第三次要做类似的事情时，应该重构
事不过三，三则重构

2 添加新特性时，重构帮助理解代码，
改好结构，更利于添加新特性

3 debug时，使代码更具可读性，
清晰到可以一眼看出bug

4 复审代码时

三、何时不该重构：

1 应该重写，而非重构的症状：代码难以正常、稳定运作。

2 大块头的软件，应该先重构为封装良好的小组件，
再对每个小组件的处理做考量

3 临近最后期限，重构提升了效率，也不会来得及完成
证明早就该重构了

四、重构的考量：

1. 重构与设计之间的考量
不需要过早对软件进行过度的设计，
过度灵活地适应未来可能的需求。

但需要合理的预先设计，
然后根据需求一点点重构、进化，
当前就实现满足需求的最简单方案即可。

灵活而复杂的设计多数时候都不需要。

2. 重构与性能之间的考量
重构使代码清晰，但往往可能使其性能下降，
但可读的代码容易优化性能，有需要的时候才做有用功，
过早地优化，可能会事倍功半，做了许多无用功。

五、间接层的用途：

1 允许逻辑共享
2 分开意图解释与具体实现
3 隔离变化
4 封装条件逻辑

六、代码异味：

1 重复的代码 Duplicated Code
2 过长的函数 Long Method
3 过大的类 Large Class
4 过长的参数列 Long Parameter List

5发散式的变化 Deivergent Change
一个类受多种变化的影响
最好让每个类只受一种变化的影响

6 霰弹式修改 Shotgun Surgery
与Divergent Change相反，它代表：
每遇到某种变化，都必须在许多不同类作出许多小修改。

7 依恋情结 Feature Envy
对象技术要点：将数据和对数据的操作行为包装在一起。
函数对某个类的兴趣高过对自己所处类的兴趣，
通常访问焦点就是其它类的数据，
从另一个对象调用了许多取值函数，
那么这些操作难道不该搬到另一个对象的所属类中吗？

8 数据泥团 Data Clumps
常常在不同的地方看到相同的三四项数据，
两个类中相同的字段、许多函数签名中有相同的参数。
应该将它们提炼到独立的对象中去，
然后就可以精简过长参数列、冗余的数据和重复的代码……

9 基本类型偏执 Primitive Obsession
基本类型built-in type，构成了结构类型的积木块，
结构类型肯定会带来额外的开销。

为了效率使用基本类型去代表货币、电话、邮政编码，
让逻辑变复杂，类型不安全，走回传统老路，
还丢掉了面向对象的优点，何苦呢？
真正性能优化应该花在重点上，而非细枝末节上。

10 switch 惊悚现身 Switch Statements
面向对象程序的显著特征：少用switch语句。
因为它重复，可以用继承多态解决这个问题。

11 平行继承体系 Parallel Inheritance Hierarchies
其实是Shotgun Surgery的特殊情况，症状：
每当为一个类增加一个子类，也必须为另一个类相应增加一个子类。
最好先用其中一个继承体系引用另一个继承体系的实例，
再慢慢用重构技巧将另一个体系消解掉。

12 冗赘类 Lazy Class
每个类都需要人取创造、理解、维护，有代价（花钱和精力）。
如果一个类的存在价值，抵不上它的代价，就该消失。
某些类的存在是为了应对某种变化和的情况，
但很可能变化没有发生，或者变化不同于预期。

13 夸夸其谈未来性 Speculative Generality
为了未来可能的情况，而预设某些设计，
造成系统更难理解和维护，到底值不值得？
多余的抽象层次、钩子、特殊情况，都不该存在！

14 令人迷惑的暂时字段 Temporary Field
某个实例变量仅为某种特定情况而设，
当它不再被使用，怎么猜测它当初的设置目的，会令人发疯的。
当一个复杂的算法需要好几个变量，就很可能出现这种状况。

15 过度耦合的消息链 Message Chains
消息链：用户向一个对象请求另一个对象，
然后后者又请求另一个对象，然后……

一旦对象间的关系发生了变化（可能消息链断裂？），
就不得不做出相应的修改。
（个人经验不足，对此理解不深，在此不赘述，详看原文）

16 中间人 Middle Man
对象的基本特征之一，封装：对外部世界隐藏其内部细节。
封装往往伴随着委托。
你可能看到一个类，有很多接口都委托给了其它类，这就是过度运用。
最好让该类跟直接处理事务的类进行交互，
中间过多的委托动作很可能是不必要的负担。

17 狎昵关系 Inappropriate Intimacy
有时两个类过于紧密，花费太多代码用于探究相互间的private成分。
要不将它们的共同点提取到一个安全的类，然后共用新类，
或者使用委托delegate，来避免其过分紧密，但确实是不同的东西。
（个人经验不足，对此理解不深）

18 异曲同工的类 Alternative Classes with Different Interfaces
做同一件事的两个类，却有着不同的签名。

19 不完美的库类 Incomplete Library Class
复用常被视为对象的终极目的。
复用的意义常常被高估——大多数对象只要够用就好。

库常常构造得不够好，这是难免的，因为任务艰巨，难以面面俱到。
如果想要完善库类，而且只要修改库类的一两个函数，
可以Introduce Foreign Method；
如果要添加一大堆额外行为，旧的运用Introduce Local Extension。
（个人经验不足，对此理解不深）

20 幼稚的数据类 Data Class
Data Class：拥有一些字段，以及用于读写它们的set/get函数，除此之外一无长物。
它就是不会说话的数据容器，几乎一定被其它类细琐地操控着。
那些细琐的操作应该尝试搬移到它的身上，让其负起应负的责任。

21 被拒绝的遗赠 Refused Bequest
子类应该继承超类的函数和数据，
如果它们不想、不需要继承呢？
因为可能其中有许多特性子类是不需要的。

这意味着传统意义上的继承体系的设计错误。
如果子类复用了超类的实现，但拒绝继承超类的接口，
那何苦继承呢，如果硬要继承，可以对继承体系进行优化，
可是打乱了原有的继承关系有必要吗？
有Replace Inheritance with Delegation来解决这种问题。

22 过多的注释 Comments
尽量让注释显得多余。
记录的应该是Why之类的言语，
而非How、What，让代码自解释。

七、构筑测试体系：

可靠、自动化的测试，方便排除bug，
可以证明代码修改后依然正常运行（回归测试）。

要使测试的构建完善，使测试编写、进行、回显很方便，
否则没人愿意进行麻烦的测试，使流程推动技术革命，
而非增加太多没有用的人工审核流程，人都会贪方便。

写实现时，思路比较清晰，就该顺手写好其测试用例，
看似麻烦，但是很有必要。
因为找bug的时间，比debug的时间还多，
找bug比解决bug还麻烦。

在写实现之前，就写好测试有一定好处，
可以提醒自己，更关注接口而非实现，突出目标。

小步快跑，快速推进，
每次编译后进行（针对刚实现完成部分的少数几个）测试，
频繁针对刚写好的代码进行测试，方便很快发现、理解、修复错误。

最好每天都能完整跑完一次所有的测试，保证代码可靠性。
但是要谨记，测试并不能找出所有bug！

八、重构列表：

重构的记录格式——
1 名称name     重构词汇表
2 概要summary     简要介绍适用场景，所做的操作
3 动机motivation     为什么需要这种重构，什么情况不该使用
4 做法mechanics     详细步骤、方法
5 范例example     简单的例子说明重构手法的运作

寻找引用点——
不要盲目使用文本搜索、替换，尤其正则，
因为不同的类的函数可能有相同的函数名，
可能还存在某个继承体系中，某个方法被多次覆盖重写的情况。

还有利用反射机制对某个函数、类进行调用的方式，尽可能避免！
暂时的类型推导，引用检索，不一定能检索到，
所以会导致一定危险，你以为没有被使用的代码，
被用了反射机制的代码使用了！

九、重新组织函数

手段

提取函数 将过长函数变短，职能单一化，单一责任原则
替换中间变量 没有变化的单一变量，直接用查询函数代替！
条件判断换为多态
