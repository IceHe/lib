title: Effective C++ 4
date: 2015-02-04
noupdate: true
categories: [C++]
tags: [C++]
description: C++ Advanced - Note&#58; parameter-independent 参数无关的代码抽离 templates；member function templates 运用成员函数模板接受所有兼容类型；请使用 traits class 表现类型信息；template metaprograming；new-handler；placement new，placement delete；不要轻忽编译器的警告；Boost，TR1。
---

<ul><li>Created on 2014-05</li></ul><br/>

<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><b style="font-size: 16px;">条款44：将参数无关的代码抽离templates<br/></b></div><div><b style="font-size: 16px;">factor parameter-independent code out of templates.</b></div><div><b style="font-size: 16px;"><br/></b></div><div><span style="font-size: 16px;">1.Templates生成多个classes和多个函数，所以</span></div><div><span style="font-size: 16px;">任何template代码都不该与某个造成膨胀的template参数产生相依关系。</span></div><div><span style="font-size: 16px;">2.因非类型模板参数（non-type template parameters）而造成的代码膨胀，</span></div><div><span style="font-size: 16px;">往往可以消除，做法是以函数参数或class成员变量替换template参数。</span></div><div><span style="font-size: 16px;">3.因类型参数（type parameters）而造成的代码膨胀，往往可降低，</span></div><div><span style="font-size: 16px;">做法是让带有完全相同二进制表述（binary representations）的具现类型</span></div><div><span style="font-size: 16px;">（instantiation type）共享实现码。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">template&lt;typename T, std::size_t n&gt; // n就是非类型参数</span></div><div><span style="font-size: 16px;">class SquareMatrix{</span></div><div><font size="4">public:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;void invert();</font></div><div><span style="font-size: 16px;">};</span></div><div><b style="font-size: 16px;"><br/></b></div><div><b style="font-size: 16px;"><br/></b></div><div><b style="font-size: 16px;">条款45：运用成员函数模板接受所有兼容类型</b></div><div><b style="font-size: 16px;">use member function templates to accept &quot;all compatible types&quot;.</b></div><div><b style="font-size: 16px;"><br/></b></div><div><font size="4">1.请使用member function templates（成员函数模板）</font></div><div><font size="4">生成“可接受所有兼容类型”的函数。</font></div><div><font size="4">2.如果你声明member templates用于“泛化copy构造”或“泛化ssignment操作”，</font></div><div><font size="4">你还是需要声明正常的copy构造函数和copy assignment操作符。</font></div><div><font size="4"><br/></font></div><div><font size="4">template&lt;typename T&gt;</font></div><div><font size="4">class SmartPtr{</font></div><div><font size="4">public:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;template&lt;typename U&gt;</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;SmartPtr(const SmartPtr&lt;U&gt;&amp; other)</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : heldPtr(other.get()) {</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;}</font></div><div><font size="4">private:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;T* heldPtr;</font></div><div><font size="4">};</font></div><div><b style="font-size: 16px;"><br/></b></div><div><b style="font-size: 16px;"><br/></b></div><div><b style="font-size: 16px;">条款46：需要类型转换时请为模板定义非成员函数</b></div><div><b style="font-size: 16px;">define non-member functions inside templates when type conversion are desired.</b></div><div><b style="font-size: 16px;"><br/></b></div><div><font size="4">此条目相当复杂，所以最好查看原书。</font></div><div><font size="4"><br/></font></div><div><font size="4">当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数值之隐式类型转换”时，</font></div><div><font size="4">请将那些函数定义为“class template内部的friend函数”。</font></div><div><b style="font-size: 16px;"><br/></b></div><div><b style="font-size: 16px;"><br/></b></div><div><b style="font-size: 16px;">条款47：请使用traits class表现类型信息</b></div><div><font size="4"><b>use traits classes for information about types.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">traits广泛应用于标准程序库。</font></div><div><font size="4">但是，平时使用很少，导致看得不深入，难懂。</font></div><div><font size="4">最好，看原书的条款。此处不详述太多。</font></div><div><font size="4"><br/></font></div><div><font size="4">如何设计并实现一个traits class：</font></div><div><font size="4">（1）确认若干你希望将来可取得的类型相关信息。如迭代器的种类。</font></div><div><font size="4">（2）为该信息选择一个名称。如iterator_category。</font></div><div><font size="4">（3）提供一个template和一组特化版本（如iterator_traits），</font><span style="font-size: large;">内含你希望支持的类型相关信息。</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;">// 对于5种迭代器种类，C++标准程序库分别提供专属的卷标结构（tag struct）</span></div><div><span style="font-size: large;">struct input_iterator_tag {};</span></div><div><span style="font-size: large;">struct output_iterator_tag {};</span></div><div><span style="font-size: large;">struct forward_iterator_tag : public input_iterator_tag {};</span></div><div><span style="font-size: large;">struct&nbsp;</span><span style="font-size: large;">bidirectional_iterator_tag</span><span style="font-size: large;">&nbsp;: public&nbsp;</span><span style="font-size: large;">forward_iterator_tag</span><span style="font-size: large;">&nbsp;{};</span></div><div><span style="font-size: large;">struct&nbsp;</span><span style="font-size: large;">random_access_iterator_tag</span><span style="font-size: large;">&nbsp;: public&nbsp;</span><span style="font-size: large;">bidirectional_iterator_tag</span><span style="font-size: large;">&nbsp;{};</span></div><div><span style="font-size: large;"><br/></span></div><div><font size="4">template&lt;...&gt; // 略而未写的template参数</font></div><div><font size="4">class deque{</font></div><div><font size="4">public:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;class iterator{</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;public:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typedef random_access_iterator_tag iterator_category;</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;};</font></div><div><font size="4">};</font></div><div><font size="4"><br/></font></div><div><font size="4">template&lt;...&gt; // 略而未写的template参数</font></div><div><font size="4">class list{</font></div><div><font size="4">public:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;class iterator{</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;public:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typedef bidirectional_iterator_tag iterator_category;</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;};</font></div><div><font size="4">};</font></div><div><font size="4"><br/></font></div><div><font size="4">template&lt;typename IterT&gt;</font></div><div><font size="4">struct iterator_traits{</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;typedef typename IterT::iterator_category iterator_category;</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;...</font></div><div><font size="4">}; // 它对用户自定义类型行得通，但对指针（另一种迭代器）行不通。</font></div><div><font size="4">// 因为指针不可能嵌套typedef。</font></div><div><font size="4"><br/></font></div><div><font size="4">template&lt;typename IterT&gt;</font></div><div><font size="4">struct iterator_traits&lt;IterT*&gt;{ // 利用偏特化解决，支持了指针迭代器</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;typedef&nbsp;</font><span style="font-size: large;">random_access_iterator_tag</span><span style="font-size: large;">&nbsp;</span><span style="font-size: large;">iterator_category;</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;...</span></div><div><font size="4">}</font></div><div><font size="4"><br/></font></div><div><font size="4">// advance函数用于移动迭代器</font></div><div><font size="4">// 以下代码是，利用重载技术，</font><span style="font-size: large;">在编译期对类型执行取代if...else测试</span></div><div><font size="4">template&lt;typename IterT, typename DistT&gt;</font></div><div><font size="4">void doAdvance(IterT&amp; iter, DistT d, std::</font><span style="font-size: large;">random_access_iterator_tag){</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;iter += d;</span></div><div><span style="font-size: large;">}</span></div><div><span style="font-size: large;"><br/></span></div><div><font size="4">template&lt;typename IterT, typename DistT&gt;</font></div><div><font size="4">void doAdvance(IterT&amp; iter, DistT d, std::</font><span style="font-size: large;">bidirectional_iterator_tag</span><span style="font-size: large;">){...</span><span style="font-size: large;">}</span></div><div><span style="font-size: large;"><br/></span></div><div><font size="4">template&lt;typename IterT, typename DistT&gt;</font></div><div><font size="4">void doAdvance(IterT&amp; iter, DistT d, std::</font><span style="font-size: large;">input_iterator_tag</span><span style="font-size: large;">){...</span><span style="font-size: large;">}</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;"><br/></span></div><div><font size="4">template&lt;typename IterT, typename DistT&gt;</font></div><div><font size="4">void advance(IterT&amp; iter, DistT d</font><span style="font-size: large;">){</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;<b>doAdvance(iter, d, typename std::</b></span><span style="font-size: large;"><b>iterator_traits&lt;IterT&gt;::iterator_category();</b></span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;// 这里就不用if...else去测试用那种方式去移动迭代器了！</span></div><div><span style="font-size: large;">}</span></div><div><font size="4"><br/></font></div><div><font size="4">1.Traits classes使得“类型相关信息”在编译期可用。</font></div><div><font size="4">它们以templates和“templates特化”完成实现。</font></div><div><font size="4">2.整合重载技术（overloading）后，</font></div><div><font size="4">traits classes有可能在编译期对类型执行if...else测试</font></div><div><font size="4"><b><br/></b></font></div><div><font size="4"><b><br/></b></font></div><div><b style="font-size: 16px;">条款48：认识template元编程</b></div><div><font size="4"><b>be aware of template metaprograming.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">1.Template metaprograming（TMP，模板元编程）可将工作由运行期移往编译期，</font></div><div><font size="4">因而得以实现早期错误侦测，和更高的执行效率！</font></div><div><font size="4">2.TMP可被用来生成“基于政策选择组合”（based on combinations of policy choices）</font></div><div><font size="4">的客户定制代码，也可用来避免生成对某些特殊类型并不合适的代码。</font></div><div><font size="4"><br/></font></div><div><font size="4">TMP已被证明是个“图灵完全”（turing-complete）机器，意思是它的威力大到足以计算任何事物。</font></div><div><font size="4"><br/></font></div><div><font size="4">TMP没有循环构件，循环效果由递归完成recursion。</font></div><div><font size="4">但其递归非递归函数调用，而是“递归模板具现化”（recursive template instantiation）。</font></div><div><font size="4">如下的阶乘例子（factorial）：</font></div><div><font size="4"><br/></font></div><div><font size="4">template&lt;unsigned n&gt;</font></div><div><font size="4">struct Factorial{</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;enum { value = n * Factorial&lt;n - 1&gt;::value }; // enum hack</font></div><div><font size="4">};</font></div><div><font size="4">template&lt;&gt;</font></div><div><font size="4">struct Factorial&lt;0&gt;{ // 模板特化</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;enum { value = 1 };</font></div><div><font size="4">};</font></div><div><font size="4">只要你指涉Factorial&lt;n&gt;::value就可以得到n阶乘值。</font></div><div><font size="4"><br/></font></div><div><font size="4">为什么TMP值得学习？</font></div><div><font size="4">（1）确保度量单位正确。使用它，就可以确保（在编译期）程序中所有度量单位的组合都正确，</font></div><div><font size="4">不论计算多复杂。所以它能用于早期侦测。</font></div><div><font size="4">（2）优化矩阵运算。</font></div><div><font size="4">Matrix m1, m2, m3;</font></div><div><font size="4">Matrix res = m1 * m2 * m3;</font></div><div><font size="4">用高级与TMP相关的template技术，即expression templates，</font></div><div><font size="4">就可能消除那些计算中临时产生的对象，并合并循环。</font></div><div><font size="4">使其使用较少的内存，执行速度有大提升。</font></div><div><font size="4">（3）可以生成客户定制之设计模式（custom design pattern）实现品。</font></div><div><font size="4">设计模式如Strategy、Ovserver、Visitor等等都可以多种方式实现出来。</font></div><div><font size="4">运用policy-based design之TMP-based技术，可能产生一些templates用来表述的独立设计选项，</font></div><div><font size="4">可任意组合他们，导致模式实现品带着客户定制的行为。</font></div><div><font size="4">例如智能指针。</font></div><div><font size="4"><b><br/></b></font></div><div><font size="4"><b><br/></b></font></div><div><b style="font-size: 16px;">条款49：了解new-handler的行为</b></div><div><font size="4"><b>understand the behavior of the new-handler.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">STL容器所使用的heap内存是由容器所拥有的分配器对象（allocator objects）管理，</font></div><div><font size="4">不是被new和delete直接管理。</font></div><div><font size="4"><br/></font></div><div><font size="4">当operator new<b>抛出异常</b>以反映一个未获满足的内存需求<b>之前</b>，</font></div><div><font size="4">它会<b>先调用</b>一个客户制定的错误处理函数，即<b>new-handler</b>。</font></div><div><font size="4"><br/></font></div><div><font size="4">namespace std{</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;typedef void (*new_handler)();</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;new_handler set_new_handler(new_handler p) throw();</font></div><div><font size="4">} // 其返回值也是一个指针，指向set_new_handler被调用前正在执行</font></div><div><font size="4">// （但马上就要被替换）的那个new-handler函数。</font></div><div><font size="4"><br/></font></div><div><font size="4">当operator new无法满足内存申请时，会不断调用new-handler函数函数，直到找到足够内存。</font></div><div><font size="4">设计良好的new-handler必须做以下事情：</font></div><div><font size="4">（1）让更多内存可被使用。</font></div><div><font size="4">（2）安装另一个new-handler。</font></div><div><font size="4">如果目前这个new-handler无法取得更多可用内存，或许它直到另外哪个new-handler有此能力。</font></div><div><font size="4">（3）卸载new-handler。</font></div><div><font size="4">也就是将null指针传给set_new_handler。</font></div><div><font size="4">一旦没有安装任何new-handler，operator new会在内存分配不成功时抛出异常。</font></div><div><font size="4">（4）抛出bad_alloc（或派生自bad_alloc）的异常。</font></div><div><font size="4">这样的异常不会被operator new捕捉，</font><span style="font-size: large;">因此会被传播到内存索求处。</span></div><div><span style="font-size: large;">（5）不返回，通常调用abort或exit。</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;">C++不支持class专属的new-handler，其实也不需要。</span></div><div><span style="font-size: large;">可令每个class提供自己的operator new和new-handler即可。</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;">template&lt;typename T&gt;</span></div><div><span style="font-size: large;">class NewHandlerSupport{</span></div><div><span style="font-size: large;">public:</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;static std::new_handler set_new_handler(std::new_handler p) throw();</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;static void* operator new(std::size_t size) throw(std::bad_alloc);</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;...</span></div><div><span style="font-size: large;">private:</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;static std::new_handler currentHandler;</span></div><div><span style="font-size: large;">};</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;">template&lt;typename T&gt;</span></div><div><span style="font-size: large;">std::new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw(){</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;std::new_handler oldHandler = currentHandler;</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;currentHandler = p;</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;return oldHandler;</span></div><div><span style="font-size: large;">}</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;">template&lt;typename T&gt;</span></div><div><font size="4">void* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size) : throw(std::bad_alloc){</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;NewHandlerHolder h(std::set_new_handler(currentHandler));</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;return ::operator new(size);</font></div><div><font size="4">}</font></div><div><font size="4">// 1.调用set_new_handler，告知Widget的错误处理函数。</font></div><div><font size="4">// 2.调用global operator new，执行实际的内存分配。</font></div><div><font size="4">// 如果失败，operator new会调用Widget专属的new-handler。</font></div><div><font size="4">// 若最终还是无法分配足够内存，会抛出bad_alloc异常。</font></div><div><font size="4">// 然而之后，还要恢复原本的global new-handler，</font></div><div><font size="4">// 然后再传播该异常。为了将原来的handler安装回去，</font></div><div><font size="4">// 使用了资源管理对象，实例即是以下的</font><span style="font-size: large;">NewHandlerHolder，防止资源泄漏。</span></div><div><span style="font-size: large;">// 3.global operator new能够分配足够的内存，operator new会返回一个指针，指向分配所得。</span></div><div><span style="font-size: large;">// Widget的析构函数会管理global new-handler，</span></div><div><span style="font-size: large;">// 自动将Widget&apos;s operator new被调用之前的那个new-handler恢复回来~！</span></div><div><font size="4"><br/></font></div><div><font size="4">template&lt;typename T&gt;<br/>
std::new_handler NewHolderSupport&lt;T&gt;::currentHandler = 0;</font></div><div><font size="4"><br/></font></div><div><font size="4">class NewHandlerHolder{</font></div><div><font size="4">public:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;explicit NewHandlerHolder(std::new_handler nh)</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : handler(nh){</font><span style="font-size: large;">}</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;~newHandlerHolder(){</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::set_new_handler(handler);</span></div><div><font size="4">&nbsp; &nbsp; &nbsp;}</font></div><div><font size="4">private:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;std::new_handler handler;</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;NewHandlerHolder(const NewHandlerHolder&amp;);</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;NewHandlerHolder&amp; operator=(const NewHandlerHolder&amp;);</font></div><div><font size="4">};</font></div><div><span style="font-size: large;"><br/></span></div><div><font size="4">1.set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。</font></div><div><font size="4">2.Nothrow new是一个颇为局限的工具，因为它只适用于内存分配；</font></div><div><font size="4">后继的构造函数调用还是可能抛出异常。</font></div><div><font size="4"><b><br/></b></font></div><div><b style="font-size: 16px;">条款50：了解new和delete的合理替换时机</b></div><div><b style="font-size: 16px;">understand when it makes sense to replace new and delete.</b></div><div><b style="font-size: 16px;"><br/></b></div><div><font size="4">为什么要替换编译器提供的operator new&amp;delete呢？</font></div><div><font size="4"><br/></font></div><div><font size="4">（1）用来检测运用上的错误。</font></div><div><font size="4">如，new的资源不小心delete掉时，导致内存泄露。</font></div><div><font size="4">如，多次delete，导致了不确定行为。</font></div><div><font size="4">这些都容易识别。但各式各样的编程错误导致</font></div><div><font size="4">overruns（写入点在分配区块之后）或underruns（写入点在分配区块起点之前）。</font></div><div><font size="4">自定义的operator new就可以分配额外空间防止特定byte pattern（即签名，signatures）</font></div><div><font size="4">，检查分配区块在某生命时间点，是否发生了overruns或underruns。</font></div><div><font size="4">（2）为了强化效能。</font></div><div><font size="4">定制版性能可以优化超过缺省版本。</font></div><div><font size="4">（3）为了收集使用上的统计数据。</font></div><div><font size="4">（4）为了增加分配和归还的速度。</font></div><div><font size="4">（5）为了降低缺省内存管理器带来的空间额外开销。</font></div><div><font size="4">针对小型对象而开发的分配器（例如Boost的Pool程序库）本质上消除了这样的额外开销。</font></div><div><font size="4">（6）为了弥补却生分配其中的非最佳齐位（suboptimal alignment）。</font></div><div><font size="4">如doubles的访问在x86体系结构上的访问是最快速的。</font></div><div><font size="4">（7）为了将相关对象成簇集中。</font></div><div><font size="4">（8）为了获得非传统的行为。</font></div><div><font size="4"><br/></font></div><div><b style="font-size: 16px;"><br/></b></div><div><b style="font-size: 16px;">条款51：编写new和delete时需固守常规</b></div><div><b style="font-size: 16px;">adhere to convention when writing new and delete.</b></div><div><b style="font-size: 16px;"><br/></b></div><div><font size="4">详情最好自己重看原书。以下仅给出最后书中的简单概括：</font></div><div><font size="4">1.operator new应该内含一个无穷循环，</font></div><div><font size="4">并在其中尝试分配内存，如果它无法满足内存需求，</font></div><div><font size="4">就应该调用new-handler。它也应该有能力处理0 bytes申请。</font></div><div><font size="4">专属版本则还应该处理”比正确大小更大的（错误）申请“。</font></div><div><font size="4">2.operator delete应该在收到null指针时不做任何事。</font></div><div><font size="4">class专属版本则还应该处理”比正确大小更大的（错误）申请“</font></div><div><font size="4"><br/></font></div><div><b style="font-size: 16px;"><br/></b></div><div><b style="font-size: 16px;">条款52：写了placement new也要写placement delete</b></div><div><b style="font-size: 16px;">write placement delete if you write placement new.</b></div><div><font size="4"><b><br/></b></font></div><div><span style="font-size: large;">详情最好自己重看原书。以下仅给出最后书中的简单概括：</span></div><div><span style="font-size: large;">void* operator new(std::size_t) throw(std::bad_alloc); // normal new</span></div><div><span style="font-size: large;">void* operator new(std::size_t, void*) throw(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// placement new</span></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 从void*指针制定的位置开始分配内存</font></div><div><span style="font-size: large;">void* operator new(std::size_t, const std::nothrow_t&amp;) throw(); // nothrow new</span></div><div><font size="4"><b><br/></b></font></div><div><font size="4">new和delete如果接受了额外参数，便称为placement的。</font></div><div><font size="4">如果一个带额外参数的operator new没有”带相同额外参数“的对应版operator delete，</font></div><div><font size="4">那么当new的内存分配动作需要取消并恢复旧观时就没有人员和operator delete会被调用。</font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">1.当你写一个placement operator new，请确定也写出了对应的placement operator delete。</font></div><div><font size="4">如果没有这样做，你的程序可能因为发生隐微而时断时续的内存泄露。</font></div><div><font size="4">2.当你声明placement new和placement delete，请确定不要无意识（非故意）地掩盖了它们的正常版本。</font></div><div><font size="4"><b><br/></b></font></div><div><b style="font-size: 16px;">条款53：不要轻忽编译器的警告</b></div><div><b style="font-size: 16px;">pay attention to compilere warnings.</b></div><div><b style="font-size: 16px;"><br/></b></div><div><font size="4">1.严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下</font></div><div><font size="4">争取”无任何警告“的荣誉。</font></div><div><font size="4">2.不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。</font></div><div><font size="4">一旦移植到另一编译器上，你原本倚赖的警告信息有可能消失。</font></div><div><b style="font-size: 16px;"><br/></b></div><div><b style="font-size: 16px;">条款54：让自己熟悉包括TR1在内的标准程序库</b></div><div><b style="font-size: 16px;">&nbsp;familiarize yourself with the standard library， including TR1.</b></div><div><b style="font-size: 16px;"><br/></b></div><div><font size="4">STL：容器、迭代器、算法、函数对象、容器适配器、函数对象适配器。</font></div><div><font size="4">iostream:自定缓冲功能。</font></div><div><font size="4">国际化支持：wchar_t。</font></div><div><font size="4">数值处理：复数模板complex、纯数值数组valarray。</font></div><div><font size="4">异常阶层体系：exception、logic_error、runtime_error……</font></div><div><font size="4">C89标准程序库：。。。</font></div><div><font size="4"><br/></font></div><div><font size="4">智能指针：。。。</font></div><div><font size="4">tr1::function、tr1::bind</font></div><div><font size="4">hash tables</font></div><div><font size="4">正则表达式Regular expresstions</font></div><div><font size="4">tuples变量组</font></div><div><font size="4">tr1::array、tr1::mem_fn、tr1::reference_wrapper</font></div><div><font size="4">随机数random number</font></div><div><font size="4">数学特殊函数</font></div><div><font size="4">c99兼容扩充</font></div><div><font size="4"><br/></font></div><div><font size="4">Type traits：用以提供类型（types）的编译器信息。</font></div><div><font size="4">tr1::result_of：是个template，用来推导函数调用的返回类型。</font></div><div><font size="4"><br/></font></div><div><b style="font-size: 16px;"><br/></b></div><div><b style="font-size: 16px;">条款55：让自己熟悉Boost</b></div><div><b style="font-size: 16px;">Familiarize yourself with Boost</b></div><div><b style="font-size: 16px;"><br/></b></div><div><font size="4">Boost程序库对付的主题非常繁多，区分数十个类目，包括：</font></div><div><font size="4">1.字符串与文本处理</font></div><div><font size="4">2.容器</font></div><div><font size="4">3.函数对象和高级编程（例如lambda）</font></div><div><font size="4">4.泛型编程</font></div><div><font size="4">5.模板元编程</font></div><div><font size="4">6.数学和数值</font></div><div><font size="4">7. 正确性与测试</font></div><div><font size="4">8.数据结构</font></div><div><font size="4">9.语言间的支持</font></div><div><font size="4">10.内存</font></div><div><font size="4">11.杂项</font></div><div><font size="4"><br/></font></div><div><font size="4">（1）Boost是一个社群，也是一个网站。</font></div><div><font size="4">致力于免费、源码开放、同僚复审的C++程序库开发。</font></div><div><font size="4">Boost在C++标准化过程中扮演深具影响力的角色。</font></div><div><font size="4">（2）Boost提供许多TR1组件实现品，以及其它许多程序库。</font></div><div><b style="font-size: 16px;"><br/></b></div></div>
