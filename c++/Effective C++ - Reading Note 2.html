title: Effective C++ 2
date: 2015-02-02
noupdate: true
categories: [C++]
tags: [C++]
description: C++ Advanced - Note&#58; class 类；宁以 pass-by-reference-to-const 替换 pass-by-value；错误返回 reference；private 私有；宁以 non-member、non-friend 替换 member 函数；类型转换；不抛出异常的 swap 函数；尽可能延后变量定义式的出现时间；minimize casting 尽量少做转型操作。
---

<ul><li>Created on 2014-05</li></ul><br/>

<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><font size="4"><b>条款19：设计class犹如设计type</b></font></div><div><font size="4"><b>treat class design as type design.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">注意：</font></div><div><font size="4">1.新type的对戏那个如何被创建和销毁：</font></div><div><font size="4">以及构造、析构函数，内存分配和释放函数。</font></div><div><font size="4">2.对象的初始化和对象的赋值有什么区别。</font></div><div><font size="4">3.新type对象如果被以值传递，意味着什么？</font></div><div><font size="4">4.什么是新type的合法值？</font></div><div><font size="4">5.你的新type需要配合某个继承图系吗？(inheritance graph)</font></div><div><font size="4">6.你的新type需要什么样的类型转换？</font></div><div><font size="4">7.什么样的操作符和函数对此新type是合理的？</font></div><div><font size="4">8.什么样的标准函数应该驳回？（注意必须声明为private者）</font></div><div><font size="4">9.谁该取用新type的成员？决定哪些是private/public/protected/friend 等。</font></div><div><font size="4">10.什么是新type的未声明接口（undeclared interface）？</font></div><div><font size="4">11.你的新type有多么一般化？考虑它成为一个类模版。class template</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款20：宁以pass-by-reference-to-const替换pass-by-value</b></font></div><div><font size="4"><b>perfer pass-by-reference-to-const to pass-by-value.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">缺省情况下C++以by value方式传递对象至函数，</font></div><div><font size="4">函数参数就是实际实参的复本，由对象的copy构造函数提供。</font></div><div><font size="4"><br/></font></div><div><span style="font-size: large;">pass-by-reference-to-const效率更高，减少了复本对象及其成员对象的构造和析构。</span></div><div><font size="4">而且还可以避免slicing（对象切割）的问题。</font></div><div><font size="4">当一个derived class对象以by-value方式传递并被视为base class对象，</font></div><div><font size="4">base class的copy构造函数会被调用，导致derived class对象的那些特化兴致被切割掉了，</font></div><div><font size="4">只剩下一个base class对象。</font></div><div><font size="4"><br/></font></div><div><font size="4">一般而言，可以合理假设：内置对象和STL的迭代器和函数对象，可以pass-by-value！</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><b style="font-size: large;">条款21：必须返回对象时，别妄想返回其reference</b></div><div><b style="font-size: large;">don&apos;t try to return a reference when you must return an object.</b></div><div><b style="font-size: large;"><br/></b></div><div><font size="4">任何函数如果返回一个reference或pointer指向某个local对象，都会一败涂地！</font></div><div><font size="4"><br/></font></div><div align="left"><font color="#2B91AF" face="Times New Roman" size="1"><span style="font-size:9pt">TestObj</span></font><font face="Times New Roman" size="1"><span style="font-size:9pt">&amp; retLocalObj2(){</span></font></div><div align="left"><font face="Times New Roman" size="1"><span style="font-size:9pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font color="#2B91AF" face="Times New Roman" size="1"><span style="font-size:9pt">TestObj</span></font> <font face="Times New Roman" size="1"><span style="font-size:9pt">a(2);</span></font></div><div align="left"><font face="Times New Roman" size="1"><span style="font-size:9pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font color="#0000FF" face="Times New Roman" size="1"><span style="font-size:9pt">return</span></font> <font face="Times New Roman" size="1"><span style="font-size:9pt">a;</span></font></div><div align="left"><font face="Times New Roman" size="1"><span style="font-size:9pt">}</span></font></div><div align="left"><font face="Times New Roman" size="1"><span style="font-size:9pt"><br/></span></font></div><div align="left"><font color="#2B91AF" face="Times New Roman" size="1"><span style="font-size:9pt">TestObj</span></font><font face="Times New Roman" size="1"><span style="font-size:9pt">&amp; retLocalObj3(){</span></font></div><div align="left"><font face="Times New Roman" size="1"><span style="font-size:9pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font color="#2B91AF" face="Times New Roman" size="1"><span style="font-size:9pt">TestObj</span></font> <font face="Times New Roman" size="1"><span style="font-size:9pt">*a =</span></font> <font color="#0000FF" face="Times New Roman" size="1"><span style="font-size:9pt">new</span></font> <font color="#2B91AF" face="Times New Roman" size="1"><span style="font-size:9pt">TestObj</span></font><font face="Times New Roman" size="1"><span style="font-size:9pt">(3);</span></font></div><div align="left"><font face="Times New Roman" size="1"><span style="font-size:9pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font color="#0000FF" face="Times New Roman" size="1"><span style="font-size:9pt">return</span></font> <font face="Times New Roman" size="1"><span style="font-size:9pt">*a;</span></font></div><div align="left"><font face="Times New Roman" size="1"><span style="font-size:9pt">}</span></font></div><div align="left"><font face="Times New Roman" size="1"><span style="font-size:9pt"><br/></span></font></div><div align="left"><font color="#2B91AF" face="Times New Roman" size="1"><span style="font-size:9pt">TestObj</span></font><font face="Times New Roman" size="1"><span style="font-size:9pt">* retLocalObj4(){</span></font></div><div align="left"><font face="Times New Roman" size="1"><span style="font-size:9pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font color="#2B91AF" face="Times New Roman" size="1"><span style="font-size:9pt">TestObj</span></font> <font face="Times New Roman" size="1"><span style="font-size:9pt">*a =</span></font> <font color="#0000FF" face="Times New Roman" size="1"><span style="font-size:9pt">new</span></font> <font color="#2B91AF" face="Times New Roman" size="1"><span style="font-size:9pt">TestObj</span></font><font face="Times New Roman" size="1"><span style="font-size:9pt">(4);</span></font></div><div align="left"><font face="Times New Roman" size="1"><span style="font-size:9pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font color="#0000FF" face="Times New Roman" size="1"><span style="font-size:9pt">return</span></font> <font face="Times New Roman" size="1"><span style="font-size:9pt">a;</span></font></div><div align="left"><font face="Times New Roman" size="1"><span style="font-size:9pt">}</span></font></div><div align="left"><font face="Times New Roman" size="1"><span style="font-size:9pt"><br/></span></font></div><div align="left" style="font-size: 16px;"><font face="Times New Roman">以上第一个例中，local object建立在栈上，返回时</font><span style="font-family: &amp;apos;Times New Roman&amp;apos;;">local object已</span><span style="font-family: &amp;apos;Times New Roman&amp;apos;;">会被释放。</span></div><div align="left"><div style="font-size: 16px;"><span style="font-family: &amp;apos;Times New Roman&amp;apos;;">第二、三个例中，local object建立在堆上，返回的</span><span style="font-family: &amp;apos;Times New Roman&amp;apos;;">local object不会被释放，</span></div><div style="font-size: 16px;"><span style="font-family: &amp;apos;Times New Roman&amp;apos;;">但是，之后谁能对这些临时的对象释放，delete？例如：</span></div><div style="font-size: 16px;"><span style="font-family: &amp;apos;Times New Roman&amp;apos;;">w =&nbsp;</span><span style="font-family: &amp;apos;Times New Roman&amp;apos;; font-size: 12px;">retLocalObj2()&nbsp;</span><span style="font-family: &amp;apos;Times New Roman&amp;apos;;">*&nbsp;</span><span style="font-family: &amp;apos;Times New Roman&amp;apos;; font-size: 12px;">retLocalObj3()</span><span style="font-family: &amp;apos;Times New Roman&amp;apos;;">&nbsp;*&nbsp;</span><span style="font-family: &amp;apos;Times New Roman&amp;apos;; font-size: 12px;">retLocalObj4();&nbsp;</span></div><div style="font-size: 16px;"><span style="font-family: &amp;apos;Times New Roman&amp;apos;;">明显没有机会释放中间变量，导致内存泄漏。</span></div><div style="font-size: 16px;"><span style="font-family: &amp;apos;Times New Roman&amp;apos;;"><br/></span></div><div style="font-size: 16px;"><font face="Times New Roman">正确做法：</font></div><div style="font-size: 16px;"><font face="Times New Roman">必须返回新对象，就让那个函数直接返回一个新对象</font></div><div style="font-size: 16px;"><font face="Times New Roman">inline const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs){</font></div><div style="font-size: 16px;"><font face="Times New Roman">&nbsp; &nbsp; &nbsp;return Rational(lhs.n * rhs.n, lhs.d * rhs.d);</font></div><div style="font-size: 16px;"><font face="Times New Roman">}</font></div><div style="font-size: 16px;"><font face="Times New Roman">必须承受由此带来的构造、析构成本。</font></div><div style="font-size: 16px;"><span style="font-family: &amp;apos;Times New Roman&amp;apos;;"><br/></span></div><div style="font-size: 16px;"><font face="Times New Roman">绝不要返回pointer和reference指向一个local stack对象，</font></div><div style="font-size: 16px;"><font face="Times New Roman">或返回reference指向一个heap-allocated对象，</font></div><div style="font-size: 16px;"><font face="Times New Roman">或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。</font></div><div style="font-size: 16px;"><font face="Times New Roman"><br/></font></div></div><div><font size="4"><br/></font></div><div><b style="font-size: large;">条款22：将成员变量声明为private</b></div><div><b style="font-size: large;">declare data members private</b></div><div><b style="font-size: large;"><br/></b></div><div><font size="4">切记将成员变量声明为private。这可赋予客户访问数据的一致性、</font></div><div><font size="4">可细微划分放哪高温控制、允诺约束条件获得保证，</font></div><div><font size="4">并提供class作者以充分的实现弹性和日后的修改空间。</font></div><div><font size="4">protected并不比public更具有封装性，</font></div><div><font size="4">private可以使其成员变量，对其derived class更有封装性。</font></div><div><b style="font-size: large;"><br/></b></div><div><b style="font-size: large;"><br/></b></div><div><b style="font-size: large;">条款23：宁以non-member、non-friend替换member函数</b></div><div><b style="font-size: large;">prefer non-member non-friend functions to member function</b></div><div><b style="font-size: large;"><br/></b></div><div><font size="4">class WebBrowser{<br/></font></div><div><font size="4">public:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;void clearCache();</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;void clearHistory();</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;void removeCookie();</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;// void clearEverything(); // 使用这个成员函数调用前三个函数不够好</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;...</font></div><div><font size="4">}</font></div><div><font size="4">void clearBrowser(){</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;wb.clearCache();</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;wb...</font></div><div><font size="4">} // 这样更好，有更好的封装性、包裹弹性(packaging flexible)和机能扩充性。</font></div><div><font size="4">为什么呢？</font></div><div><font size="4">因为，在类内，越少的代码能够做同一件事，封装性越好</font></div><div><font size="4">clearEverything()也做到了clearCache()...等的函数的工作。</font></div><div><font size="4"><br/></font></div><div><font size="4">在所有函数必须定义在类内的语言来说，</font></div><div><font size="4">可以另外定义一个WebBrowser的工具类utility class，</font></div><div><font size="4">在其中定义一个static member函数完成相关功能。</font></div><div><b style="font-size: large;"><br/></b></div><div><b style="font-size: large;"><br/></b></div><div><b style="font-size: large;">条款24：若所有参数皆需要类型转换，请为此采用non-member函数</b></div><div><b style="font-size: large;">declare non-member functions when type conversions should apply to all parameters.</b></div><div><b style="font-size: large;"><br/></b></div><div><font size="4">class Rational{</font></div><div><font size="4">public:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;...</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;const Rational&nbsp;operator*(const Rational* rhs) const;</font></div><div><font size="4">}</font></div><div><font size="4">result = oneHalf * 2; // 正确</font></div><div><font size="4">result = 2 * oneHalf; // 错误！int 2 无法隐式转换为Rational类型</font></div><div><font size="4"><br/></font></div><div><font size="4">将operator*在类外定义即可：</font></div><div><font size="4">const Rational operator*(const Rational* lhs, const Rational* rhs){...}</font></div><div><font size="4">之前出错的语句也可以正常运行了！</font></div><div><font size="4"><br/></font></div><div><font size="4">其实可以将它定义为class Rational的friend函数，但是应该尽量避免，原因未详述。</font></div><div><font size="4"><br/></font></div><div><font size="4">如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）</font></div><div><font size="4">进行类型转换，那么这个函数必须是个non-member。</font></div><div><font size="4"><br/></font></div><div><b style="font-size: large;"><br/></b></div><div><b style="font-size: large;">条款25：考虑写出一个不抛出异常的swap函数</b></div><div><b style="font-size: large;">consider support for a non-throwing swap.</b></div><div><b style="font-size: large;"><br/></b></div><div><font size="4">1.当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常；</font></div><div><font size="4">2.如果你提供一个member swap，也该提供一个non-member swap用来调用前者。</font></div><div><font size="4">对于classes（而非templates），也请特化std::swap。</font></div><div><font size="4">3.调用swap时应针对std::swap使用using声明式，然后调用swap，</font></div><div><font size="4">并且不带有任何“命名空间资格修饰”。</font></div><div><font size="4">4.为“用户定义类型”进行std templates全特化是最好的，</font></div><div><font size="4">但千万不要尝试在std内加入某些对std而言全新的东西。</font></div><div><font size="4"><br/></font></div><div><font size="4">namespace std{<br/>
&nbsp; &nbsp; &nbsp;template&lt;typename T&gt;</font><span style="font-size: large;">&nbsp;</span><span style="font-size: large;">// std::swap的典型实现；</span></div><div><font size="4">&nbsp; &nbsp; &nbsp;void swap(T&amp; a, T&amp; b){</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T temp(a); // 只要T类型支持copying构造函数和copy assignment操作符即可</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = b;</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = temp;</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;}</font></div><div><font size="4">}</font></div><div><font size="4"><br/></font></div><div><font size="4">但是有些用户定义类型，复制的动作并非总有必要。因为，</font></div><div><font size="4">主要情况是，有些成员变量只是指针，指向一个对象，内含真正数据，</font></div><div><font size="4">（这种设计的常见表现形式是所谓的pimpl手法——pointer to implementation）</font></div><div><font size="4">两个对象只需要交换这个指针值即可。</font></div><div><font size="4">所以，可以针对这个用户定义类型，让std::swap进行特化：</font></div><div><font size="4">namespace std{</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;template&lt;&gt; &nbsp; &nbsp; // 这是std::swap针对T是Widget的特化版本</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b){</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(a.pImpl, b.pImpl);</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;}</font></div><div><font size="4">} // 但无法通过编译，因为pImpl是private成员。</font></div><div><font size="4"><br/></font></div><div><font size="4">真正解决方法：</font></div><div><font size="4">class Widget{</font></div><div><font size="4">public:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;void swap(Widget&amp; other){</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using std::swap; // 令std::swap在此函数内可用</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(pImpl, other.pImpl); // 编译器根据实际情况，</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 调用T专属的版本，或者std中一般化（泛化）的版本</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;}</font></div><div><font size="4">}</font></div><div><font size="4">namespace std{</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;template&lt;&gt;</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b){</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.swap(b);</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;}</font></div><div><font size="4">}</font></div><div><font size="4"><br/></font></div><div><span style="font-size: large;">劝告：成员版swap绝不可抛出异常。</span></div><div><b style="font-size: large;"><br/></b></div><div><b style="font-size: large;">条款26：尽可能延后变量定义式的出现时间</b></div><div><b style="font-size: large;">postpone variable definitions as long as possible.</b></div><div><b style="font-size: large;"><br/></b></div><div><font size="4">1.当一个变量需要使用时，才去声明它。</font></div><div><font size="4">2.为了提高效率，构造时就初始化好它！例：</font></div><div><font size="4">std::string encryted; // 先使用default构造函数</font></div><div><font size="4">encrypted = password; // 再用赋值操作符……</font></div><div><font size="4">不如</font></div><div><font size="4">std::string encryted(password); // 使用copy构造函数初始化了</font></div><div><font size="4"><br/></font></div><div><font size="4">循环时怎么办？</font></div><div><font size="4">Widget w;</font></div><div><font size="4">for(...){</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;w = xxx;</font></div><div><font size="4">}</font></div><div><font size="4">还是</font></div><div><font size="4">for(...){</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;Widget w = xxx;</font></div><div><font size="4">}</font></div><div><font size="4">前者效率高一点，但是w作用域扩大，可理解性和易维护性变差！</font></div><div><font size="4"><br/></font></div><div><font size="4">只有两种情况才使用前者的做法：</font></div><div><font size="4">（1）知道赋值比“构造+析构”的成本低</font></div><div><font size="4">（2）你正在处理代码中效率高度敏感的部分（performance-sensitive）</font></div><div><font size="4"><b><br/></b></font></div><div><b style="font-size: large;">条款27：尽量少做转型操作</b></div><div><b style="font-size: large;">minimize casting</b></div><div><b style="font-size: large;"><br/></b></div><div><span style="font-size: large;">(T)expr; // 两种旧式转型</span></div><div><span style="font-size: large;">T(expr);</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;">const_cast&lt;T&gt;(expr); // 将对象的常量性去除（cast away the constness）</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;">dynamic_cast&lt;T&gt;(expr); // 安全向下转型（safe downcasting）</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 决定某对象是否归属继承体系中的某个类型（之后细谈）</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 唯一无法由旧式语法执行的动作</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;">static_cast&lt;T&gt;(expr); // 强迫隐式转换（implicit conversions）</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将non-const转换为const，反向操作不能，只能用const_cast</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 或将int转成double，或相反</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将void*转成type*</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将ptr-to-base转为ptr-to-derived</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;">reinterpret_cast&lt;T&gt;(expr); // 企图进行低级转型，实际动作和结果取决于编译器</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 所以它不可移植。将一个long或int转成指针都可以。</span></div><div><span style="font-size: large;"><br/></span></div><div><font size="4">新式转型比旧式：</font></div><div><font size="4">（1）更加容易辨认，易读</font></div><div><font size="4">（2）转型动作的目标窄化，编译器容易判断出错误</font></div><div><font size="4"><br/></font></div><div><font size="4">1.尽量避免转型，在注重效率的代码中，避免dynamic_cast，</font></div><div><font size="4">最好试着发展无须转型的替代设计。</font></div><div><font size="4">2.如转型是必要的，试着将它隐藏于某个函数背后。</font></div><div><font size="4">客户可以调用该函数，使其不用将转型过程置于其代码中。</font></div><div><font size="4">3.宁可使用新式转型语法，不要使用旧式转型。清晰。</font></div><div><span style="font-size: large;"><br/></span></div><div><b style="font-size: large;"><br/></b></div><div><b style="font-size: large;">条款28：避免返回handles指向对象内部成分</b></div><div><font size="4"><b>avoid returning &quot;handles&quot; to object internals.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">避免返回handles（包括references、ptr、iterator迭代器）指向对象内部，</font></div><div><font size="4">保证封装性，帮助const成员函数的行为像个const，</font></div><div><font size="4">并将“</font><span style="font-size: large;">虚吊号码牌</span><span style="font-size: large;">”（dangling handles）的可能性降至最低。</span></div><div><span style="font-size: large;">（</span><span style="font-size: large;">虚吊号码牌，即是野指针，对象已被销毁，但是指向这个地方的指针还在</span><span style="font-size: large;">）</span></div><div><font size="4"><br/></font></div><div><font size="4"><b><br/></b></font></div><div><b style="font-size: large;">条款29：为“异常安全”而努力是值得的</b></div><div><b style="font-size: large;">strive for exception-safe code.</b></div><div><b style="font-size: large;"><br/></b></div><div><span style="font-size: large;">exception-safe 异常安全 的两个条件：</span></div><div><span style="font-size: large;">当异常抛出时，<br/>
（1）不泄露任何资源。</span></div><div><span style="font-size: large;">不会代码的出错中断，导致没有delete或者释放掉资源、互斥锁等。</span></div><div><span style="font-size: large;">（2）不允许数据败坏。</span></div><div><span style="font-size: large;">因为new失败，可能导致一个指针成为野指针。</span></div><div><span style="font-size: large;">内部的变量、状态，非原子性，不一致。</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;">异常安全函数——提供以下三个保证之一：</span></div><div><span style="font-size: large;">（1）基本承诺。</span></div><div><span style="font-size: large;">若异常被抛出，程序内的任何事物仍然保持在有效状态下。</span></div><div><span style="font-size: large;">（2）强烈保证。</span></div><div><span style="font-size: large;">若一场抛出，程序状态不改变。（即是变化都是原子性的。）</span></div><div><span style="font-size: large;">要不是成功执行的状态，要不处于函数调用前的状态。</span></div><div><span style="font-size: large;">（3）不抛掷（throw）保证。</span></div><div><span style="font-size: large;">绝不抛出异常。总是能够完成承诺的功能。</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;"><b>条款29给了我很大震动，这个条款很长，还是从原书重读较好。</b></span></div><div><font size="4"><b>因为没有想到，这个代码的严谨性超过了我以前的想象！</b></font></div><div><font size="4"><b>以下给出最好的那个代码版本：</b></font></div><div><font size="4">struct PMImpl{<br/>
&nbsp; &nbsp; &nbsp;std::tr1::shared_ptr&lt;Image&gt; bgImage;</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;int imageChanges;</font></div><div><font size="4">};&nbsp;</font><font size="4">// 为了swap-and-copy</font><span style="font-size: large;">而设计的</span><span style="font-size: large;">（之前的条款有说）</span></div><div><font size="4">class PrettyMenu{</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;...</font></div><div><font size="4">private:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;Mutex mutex; // 互斥量</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;std::tr1::shared_ptr&lt;PMImpl&gt; pImpl;</font><font size="4">&nbsp;</font><font size="4">// 为了swap-and-copy</font><span style="font-size: large;">而设计的</span></div><div><font size="4">};</font></div><div><font size="4">void PrettyMenu::changeBackground(std::istream&amp; imgSrc){</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;using std::swap;</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;Lock ml(&amp;mutex);</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;std::tr1::shared_ptr&lt;PMImpl&gt; pNew(new PMImpl(*pImpl));</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;pNew-&gt;bgImge.reset(new Image(imgSrc));</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;++pNew-&gt;imageChanges;</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;swap(pImpl, pNew);</font></div><div><font size="4">}</font></div><div><font size="4"><br/></font></div><div><font size="4">“强烈保证”往往能够以copy-and-swap实现出来，</font></div><div><font size="4">但强烈保证并非对所有函数都可实现或具有现实意义。</font></div><div><font size="4"><br/></font></div><div><font size="4"><b><br/></b></font></div><div><b style="font-size: large;">条款30：透彻了解inlining的里里外外</b></div><div><font size="4"><b>understand the ins and outs of inlining</b></font></div><div><font size="4"><br/></font></div><div><span style="font-size: large;">在class声明处，就定义函数过程的，都会隐喻为inline。</span></div><div><span style="font-size: large;"><br/></span></div><div><font size="4">virtual函数不能够被inline。</font></div><div><font size="4">千万别将构造和析构函数inline！</font></div><div><font size="4"><br/></font></div><div><font size="4">调试器，无法对inline函数设置断点。</font></div><div><font size="4"><br/></font></div><div><font size="4">将大多数inlining限制在小型、被频繁调用的函数身上。</font></div><div><font size="4">这可使日后的调试过程和二进制升级（binaryupgradability）更容易，</font></div><div><font size="4">也可使潜在的代码膨胀问题最小化，使程序速度提升的机会最大化。</font></div><div><font size="4"><br/></font></div><div><font size="4">不要只因为function template出现在头文件，就将它们声明为inline。</font></div></div>
