title: Effective C++ 1
date: 2015-02-01
noupdate: true
categories: [C++]
tags: [C++]
description: C++ Advanced - Note&#58; const、enum、inline；先初始化再使用变量；smart pointer 智能指针；virtual 虚函数；Destructor 析构函数；self-assignment 自赋值；new 和 delete；若不想使用编译器自动生成的函数，就该明确拒绝。
---

<ul><li>Created on 2014-05</li></ul><br/>

<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><span style="font-size:16px;">STL&nbsp;&nbsp;&nbsp;&nbsp; Standard Template Library</span><div><br/></div><span style="font-size:16px;">TR1&nbsp;&nbsp;&nbsp;&nbsp; 一份RFC的规范，描述加入C++标准程序库的诸多新机能。</span><br/><span style="font-size:16px;">Boost&nbsp;&nbsp;&nbsp;&nbsp; 一个网站，一个开源的C++程序库。大多数TR1的机能以它的工作为基础</span><div><br/></div><div><br/></div><span style="font-size:16px;"><b>条款2：尽量以const，enum，inline代替#define</b></span></div><div><font size="4"><b>perfer consts, enums, and inlines to #defines.</b></font></div><div><div><br/></div><span style="font-size:16px;">宏语言定义的变量名，如#define ASPECT_RATIO 1.653中的ASPECT_RATIO，</span><br/><span style="font-size:16px;">不会进入symbol table，对于编译器不可见。</span><div><br/></div><span style="font-size:16px;">（Extension：符号表，一种用于语言翻译器（例如编译器和解释器）中的数据结构。</span></div><div><span style="font-size:16px;">在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，</span></div><div><span style="font-size:16px;">比如其数据类型、作用域以及内存地址。</span></div><div><span style="font-size:16px;">如常数表、变量名表、数组名表、过程名表、标号表等等，统称为符号表。）</span><div><br/></div><div><br/></div><span style="font-size:16px;">enum hack：在类内，声明 enum｛OneConstNum = 5｝；</span></div><div><span style="font-size:16px;">用以声明一个常数。而且取enum量的地址，但对const常量可取地址。</span><div><br/></div><div><br/></div><span style="font-size:16px;"><b>条款3：尽量使用const</b></span></div><div><font size="4"><b>use const whenever possible<br/></b></font><div><br/></div><span style="font-size:16px;">基础：</span><br/><span style="font-size:16px;">char str[] = &quot;test&quot;;</span><br/><span style="font-size:16px;">char *p = str;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // non-const ptr, non-const data</span><br/><span style="font-size:16px;">const char *p = str;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // non-const ptr, const data</span><br/><span style="font-size:16px;">char * const p = str;&nbsp;&nbsp;&nbsp;&nbsp; // const ptr, non-const data</span><br/><span style="font-size:16px;">const char * const p = str; // const ptr, const data</span><br/><span style="font-size:16px;">char const *p = str;&nbsp;&nbsp;&nbsp;&nbsp; // the same as &quot;const char *p = str;&quot;</span><div><br/></div><span style="font-size:16px;">迭代器：（注意，与前面常识有悖）</span><br/><span style="font-size:16px;">std::vector&lt;int&gt; vec;</span><br/><span style="font-size:16px;">...</span><br/><span style="font-size:16px;">const std::vector&lt;int&gt;::iterator iter = vec.begin();&nbsp;&nbsp;&nbsp;&nbsp; // iter的作用像个 T* const</span><br/><span style="font-size:16px;">*iter = 10;&nbsp;&nbsp;&nbsp;&nbsp; // 没错，改变的只是它所指向的内容</span><br/><span style="font-size:16px;">++iter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 出错，iter本身是const</span><br/><span style="font-size:16px;">...</span><br/><span style="font-size:16px;">std::vector&lt;int&gt;::const_iterator cIter = vec.begin();&nbsp;&nbsp;&nbsp;&nbsp; // cIter的作用像个 const T*</span><br/><span style="font-size:16px;">*iter = 11;&nbsp;&nbsp;&nbsp;&nbsp; // 出错，*cIter是const</span><br/><span style="font-size:16px;">++iter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 没错，改变cIter</span><div><br/></div><span style="font-size: 16px;">常函数const不能改变任何成员变量，static变量除外。</span><div style="font-size: 16px;"><br/></div><span style="font-size: 16px;">当const和non-const成员函数有着实质等价的实现时，</span></div><div><span style="font-size: 16px;">令non-const版本调用const版本可避免代码重复。</span><div style="font-size: 16px;"><br/></div><div style="font-size: 16px;"><br/></div><b style="font-size: 16px;">条款4：确定对象使用前已先被初始化</b></div><div><font size="4"><b>make sure that objects are initialized before they&apos;re used.<br/></b></font><div style="font-size: 16px;"><br/></div><span style="font-size: 16px;">赋值和初始化不同：</span><br style="font-size: 16px;"/><span style="font-size: 16px;">用初始化列表来初始化自定义类型，而且效率更高，</span></div><div><span style="font-size: 16px;">如果初始化的是built-in类型，则效率与赋值一样;</span><br style="font-size: 16px;"/><span style="font-size: 16px;">在构造函数内是赋值。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><font size="4">OneClass::OneClass()</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;:theName(),</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; theAddress(),</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; thePhones(),</font></div><div><font size="4">&nbsp; &nbsp; &nbsp; num(0)</font></div><div><font size="4">{.</font><font size="4">..</font><span style="font-size: large;">}</span></div><div><font size="4">假如一个自定义类型的成员变量，还可以这样使用nothing&quot;()&quot;，</font></div><div><font size="4">去调用其default constructor。</font></div><div><font size="4"><br/></font></div><div><font size="4">成员变量初始化顺序：其类内声明的顺序，不关于初始化列表的顺序。</font></div><div><font size="4">所以，初始化列表的顺序最好和其类内声明顺序一样。</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4">编译单元：产生单一目标文件（single object file）的那些源码</font></div><div><font size="4">——单一源码文件加上其所include的头文件。</font></div><div><span style="font-size: 16px;"><br/></span></div><div><font size="4">local static对象：函数内的static对象。</font></div><div><span style="font-size: 16px;"><br/></span></div><div><font size="4">不同的编译单元内的non-local static对象的初始化顺序无明确定义。</font></div><div><font size="4">解决方法：用local static 代替non-local static，即是使用Singleton单例模式。</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款5：C++默默编写并调用哪些函数</b></font></div><div><font size="4"><b>know what functions C++ silently writes and calls.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">默认构造函数</font></div><div><font size="4">复制构造函数</font></div><div><font size="4">析构函数</font></div><div><font size="4">赋值操作符</font></div><div><font size="4"><br/></font></div><div><font size="4">编译器产生的析构函数是non-virtual的。</font></div><div><span style="font-size: large;">编译器产生的</span><font size="4">copy构造函数和copy assignment操作符的版本，</font></div><div><font size="4">只是将non-static成员变量拷贝至目标对象而已。</font></div><div><font size="4"><br/></font></div><div><font size="4">如果你有声明了一个构造函数（无论有无参数），</font></div><div><font size="4">编译器便不会给你创建default的的构造函数了。</font></div><div><font size="4"><br/></font></div><div><font size="4">若base class的copy assignment操作符被声明为private，</font></div><div><font size="4">那么编译器会拒绝为其derived class生成一个</font><span style="font-size: large;">copy assignment操作符。</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;"><br/></span></div><div><font size="4"><b>条款6：若不想使用编译器自动生成的函数，就该明确拒绝</b></font></div><div><font size="4">使用private声明它们，且不给出具体的定义。</font></div><div><font size="4">当客户企图拷贝时，编译器会阻止你；</font></div><div><font size="4">假如是友元或者成员函数试图拷贝的话，</font></div><div><font size="4">因为它们没有具体定义，linker链接器就会组织它们。</font></div><div><font size="4"><br/></font></div><div><font size="4">可以定义这样一个基类：</font></div><div><font size="4">class Uncopyable{</font></div><div><font size="4">protected:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;Uncopyable(){}</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;~Uncopyable(){}</font></div><div><font size="4">private:</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;Uncopyable(const Uncopyable&amp;);</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;Uncopyable&amp; operator=(</font><span style="font-size: large;">const Uncopyable&amp;</span><span style="font-size: large;">);</span></div><div><font size="4">}</font></div><div><font size="4"><br/></font></div><div><font size="4">class DerivedClass: private Uncopyable{<br/>
&nbsp; &nbsp; &nbsp;...</font></div><div><font size="4">};</font></div><div><font size="4">这样，帮助重用，而且其子类就都不能调用复制构造函数和复制赋值操作符了。</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款7：为多态基类声明virtual析构函数</b></font></div><div><font size="4"><b>declare destructors virtual in polymorphic base classes.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">一个基类指针指向子类对象，</font></div><div><font size="4">当这个对象析构的时候，如果基类destructor非virtual，</font></div><div><font size="4">那么只会调用基类的destructor，而子类的则没有被调用，</font></div><div><font size="4">导致部分销毁对象，内存泄漏。</font></div><div><font size="4"><br/></font></div><div><font size="4">基类有virtual函数，其子类就必须有相关的函数实现，即使其不重写。</font></div><div><font size="4"><br/></font></div><div><font size="4">如果一个class不打算成为基类，就不要声明virtual函数。</font></div><div><font size="4"><br/></font></div><div><font size="4">要实现virtual函数，必须携带vptr（virtual table pointer）虚函数表指针</font></div><div><font size="4">vptr指向一个有函数指针组成的数组，成为vtbl（virtual table）虚函数表。</font></div><div><font size="4">每一个带虚函数的class都带有一个相应的virtual table。</font></div><div><font size="4"><br/></font></div><div><font size="4">当调用虚函数，取决于该对象的vptr虚函数指针所指的virtual table虚函数表，</font></div><div><font size="4">编译器在其中寻找适当的函数指针。</font></div><div><font size="4"><br/></font></div><div><font size="4">而且这个虚指针增加了对象的大小，32位系统增加一个4Bytes的vptr，</font><span style="font-size: large;">64位则增加8Bytes。</span></div><div><font size="4">所以类内至少有一个virtual函数，才去声明虚的destructor。</font></div><div><font size="4"><br/></font></div><div><font size="4">尽量不要集成STL中不含有virtual函数的容器。</font></div><div><font size="4"><br/></font></div><div><font size="4">总结：</font></div><div><font size="4">带有polymorphic多态性质的base classes应该声明virtual destructor。</font></div><div><font size="4">或它带有任何virtual函数，它就该有虚析构函数。</font></div><div><font size="4">若一个class不作为base class使用，或不是为了多态，就别声明虚析构函数。</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款8：别让异常逃离析构函数</b></font></div><div><font size="4"><b>prevent exceptions from leaving destructors.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">析构函数绝对不要吐出异常。</font></div><div><font size="4">如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，</font></div><div><font size="4">然后吞下它们（不传播）或结束程序。</font></div><div><font size="4"><br/></font></div><div><font size="4">如果客户需要对某个操作函数运行期间抛出的异常作出反应，</font></div><div><font size="4">那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</font></div><div><font size="4"><br/></font></div><div><font size="4">C++不欢迎在析构函数中抛出异常。</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款9：绝不在构造和析构过程中调用virtual函数</b></font></div><div><font size="4"><b>never call virtual function during construction or destruction</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">在子类的构造函数运行时，</font><span style="font-size: large;">子类</span><span style="font-size: large;">自身类型被解析为基类，</span></div><div><span style="font-size: large;">调用的virtual函数是基类的，而不是子类的；</span></div><div><font size="4">析构函数一样，</font><span style="font-size: large;">子类</span><span style="font-size: large;">自身类型被解析为基类……</span></div><div><span style="font-size: large;"><br/></span></div><div><font size="4">解决方法：</font></div><div><font size="4">最好将初始化代码，另外放在一个init初始化函数内。</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款10：令 operator= 返回一个reference to *this</b></font></div><div><font size="4"><b>have assignment operators return a reference to *this.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">x = y = z;//连锁赋值</font></div><div><font size="4">为了实现连锁赋值，赋值操作符必须返回一个reference指向操作符的左侧实参。</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款11：在operator=中处理“自我赋值”</b></font></div><div><font size="4"><b>handle assignment to self in operator=.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">赋值操作一般会先释放掉左值，再给左值赋值，</font></div><div><font size="4">假如左值右值是同一个对象，会导致“在停止使用资源之前意外释放了它”！</font></div><div><font size="4">所以</font></div><div><font size="4">Widget&amp; Widget::operator=(const Widget &amp;rhs){</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;<b>if(this == &amp;rhs) return *this; // 证同测试 identity test</b></font></div><div><font size="4">&nbsp; &nbsp; &nbsp;...</font></div><div><font size="4">}</font></div><div><font size="4"><br/></font></div><div><font size="4">还有其它方法的！</font></div><div><font size="4"><br/></font></div><div><font size="4">确保对象自我赋值时operator=有良好的行为。</font></div><div><font size="4">有关技术包括：1.证同测试；2.copy-and-swap；3.精心周到的语句顺序。</font></div><div><font size="4"><br/></font></div><div><span style="font-size: large;">2.copy-and-swap；</span></div><div><font size="4">Widget tmp(rhs);</font></div><div><font size="4">swap(temp); // 交换*this和rhs的数据</font></div><div><font size="4">return *this;</font></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;">3.精心周到的语句顺序。</span></div><div><font size="4">Bitmap *pOrig = pb;</font></div><div><font size="4">this.pb = new Bitmap(*rhs.pd); // 先创建复本</font></div><div><font size="4">delete pOrig; // 再delete原本</font></div><div><font size="4">return *this;</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款12：复制对象时勿忘其每一个成分</b></font></div><div><font size="4"><b>copy all parts of an object</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。</font></div><div><font size="4"><br/></font></div><div><font size="4">PriorityCustomer::PriorityCustomer（const&nbsp;</font><span style="font-size: large;">PriorityCustomer&amp; rhs)</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;<b>: Customer(rhs),</b></span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp; priority(rhs.priority){</span></div><div><span style="font-size: large;">&nbsp; &nbsp; &nbsp;...</span></div><div><span style="font-size: large;">}</span></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;">PriorityCustomer&amp;&nbsp;</span><span style="font-size: large;">PriorityCustomer::operator=(const&nbsp;</span><span style="font-size: large;">PriorityCustomer&amp; rhs){</span></div><div><font size="4">&nbsp; &nbsp; &nbsp;</font><span style="font-size: large;"><b>Customer::operator=(rhs);</b></span></div><div><font size="4">&nbsp; &nbsp; &nbsp;priority = rhs.priority; // 其它成员变量的赋值</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;return *this;</font></div><div><font size="4">}</font></div><div><span style="font-size: large;"><br/></span></div><div><span style="font-size: large;"><br/></span></div><div><font size="4"><b>条款13：以对象管理资源</b></font></div><div><font size="4"><b>use objects to manage resources.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">Investment *pInv = createInvestment();</font></div><div><font size="4">... // 中间的代码可能抛出异常，可能return，</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;// 导致最后无法运行到delete那一行，内存泄漏</font></div><div><font size="4">delete pInv;</font></div><div><font size="4"><br/></font></div><div><font size="4">可以把资源放到对象里面，利用析构函数自动调用的机制，确保资源释放的问题。</font></div><div><font size="4">例如智能指针shared_ptr、unique_ptr。</font></div><div><font size="4">std::auto_ptr&lt;Investment&gt; pInv(createInvestment());</font></div><div><font size="4"><br/></font></div><div><font size="4">关键：</font></div><div><font size="4">1.获得资源后立即放进管理对象内。</font><span style="font-size: large;">这个观念被称为“资源取得时机便是初始化时机”。</span></div><div><span style="font-size: large;">（Resource Acquisition Is Initialization——RAII）</span></div><div><span style="font-size: large;">2.管理对象运用析构函数确保资源被释放。</span></div><div><font size="4">若资源释放动作可能导致抛出异常，看条款8怎么处理。（另外使用一个普通函数进行该操作）</font></div><div><font size="4"><br/></font></div><div><font size="4">auto_ptr和tr1::shared_ptr、unique_ptr等都在其析构函数内做delete而不是delete[]，</font></div><div><font size="4">意味着别将动态分配的array数组交给智能指针！会内存泄漏。</font></div><div><font size="4"><br/></font></div><div><font size="4">C++并没有特别针对“动态分配数组”而设计类似的智能指针，</font></div><div><font size="4">vector、string可以取代动态分配而得的数组。</font></div><div><font size="4">boost::scored_array和boost::shared_array classes，就提供了以上你想要的内容，</font></div><div><font size="4">可是还没有采纳入C++标准库中。</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款14：在资源管理类中小心copying行为</b></font></div><div><font size="4"><b>think carefully about copying behaviour in resource-managing classes.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">RAII对象被复制，应该怎么处理，有两种方式：</font></div><div><font size="4">1.禁止复制。因为这样并不合理。</font></div><div><font size="4">2.使用类似于shared_ptr的引用计数（reference-count）。</font></div><div><font size="4"><br/></font></div><div><font size="4">而且要注意：</font></div><div><font size="4">1.深拷贝底部资源</font></div><div><font size="4">2.或者转移底部资源的拥有权，如unique_ptr</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款15：在资源管理类中提供对原始资源的访问</b></font></div><div><font size="4"><b>provide access to raw resource in resource-managing classes.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">1.APIs往往要求访问原始资源raw resources，所以每个RAII class应该提供一个get()方法，<br/></font></div><div><font size="4">2.对原始资源的访问可能经由显式转换或隐式转换。</font></div><div><font size="4">一般隐式转换较方便，显式转换较安全。</font></div><div><font size="4"><br/></font></div><div><font size="4">class Font(){</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;...</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;FontHandle f; // 原始资源</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;operator FontHandle() const // 隐式转换</font></div><div><font size="4">&nbsp; &nbsp; &nbsp;{ return f; }</font></div><div><font size="4">}</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款16：成对使用new和delete时要采用相同形式</b></font></div><div><font size="4"><b>use the same form in corresponding uses of new and delete.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">避免 typedef std::string AddressLines[4]; // 忘了typedef的用法自己查查！</font></div><div><font size="4">因为当你 std::string* pal = new AddressLines;</font></div><div><font size="4">别人不知道该用delete pal; 还是 delete[] pal;（这个才正确）。</font></div><div><font size="4"><br/></font></div><div><font size="4">new时，使用了[]，必须在相应的delete表达式中也试用[]。</font></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款17：以独立语句将</b>new<b>ed对象置入智能指针</b></font></div><div><font size="4"><b>store newed objects in smart pointers in standalone statments.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">以独立语句将new出的对象储存于（置入）智能指针内。</font></div><div><font size="4">如果不这样做，一旦有一场被抛出，有可能导致难以察觉的资源泄漏。</font></div><div><font size="4"><br/></font></div><div><font size="4">processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority());</font></div><div><font size="4">不同编译器以何种顺序执行：</font></div><div><font size="4">A. &nbsp; &nbsp; new Widget</font></div><div><font size="4">B. &nbsp; &nbsp; tr1::shared_ptr的构造函数</font></div><div><font size="4">C. &nbsp; &nbsp; 调用priority()</font></div><div><font size="4"><br/></font></div><div><font size="4">假如以ACB顺序执行，“</font><span style="font-size: large;">调用priority()</span><span style="font-size: large;">”时可能抛出异常，</span></div><div><span style="font-size: large;">导致new出的Widget没有及时放入智能指针，</span></div><div><font size="4">还是导致内存泄漏了……</font></div><div><font size="4"><br/></font></div><div><font size="4">所以分开写成这样：</font></div><div><span style="font-size: large;">std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget);</span></div><div><span style="font-size: large;">processWidget(pw, priority());</span></div><div><font size="4"><br/></font></div><div><font size="4"><br/></font></div><div><font size="4"><b>条款18：让借口容易被正确被使用，不易被误用</b></font></div><div><font size="4"><b>make interface easy to use correctly and hard to use incorrectly.</b></font></div><div><font size="4"><b><br/></b></font></div><div><font size="4">函数调用的时候，参数的顺序可能出错，所以可以通过导入相应的类型预防。</font></div><div><font size="4">如：Date(const Month&amp; m, const Day&amp; d);</font></div><div><font size="4">// 而非直接用int指代月份和日，还可以用enum</font></div><div><font size="4"><br/></font></div><div><font size="4">Investment* createInvestment(); // 这样要求用户记得delete，而且不超过1次</font></div><div><font size="4">不能将责任推给智能指针，因为用户还是可能忘记使用。所以</font></div><div><font size="4">std::tr1::shared_ptr&lt;Investment&gt; createInvestment();</font></div><div><font size="4">强行返回智能指针，先发制人，要求客户使用智能指针。</font></div><div><font size="4"><br/></font></div><div><font size="4">智能指针可以指定删除器，而非总是使用delete。</font></div><div><span style="font-size: large;">std::tr1::shared_ptr&lt;Investment&gt; pInv(0, getRidOfInvestment);</span></div><div><span style="font-size: large;">getRidOfInvestment是作为删除器的函数名（函数指针）。</span></div><div><font size="4">上例并不够好，0只是个int，而非空指针，而智能指针坚持要一个指针，</font><font size="4">所以</font></div><div><span style="font-size: large;">std::tr1::shared_ptr&lt;Investment&gt; pInv(static_cast&lt;</span><span style="font-size: large;">Investment*</span><span style="font-size: large;">&gt;(0), getRidOfInvestment);</span></div><div><span style="font-size: large;"><br/></span></div><div><font size="4">阻止误用的办法：建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</font></div><div><font size="4">tr1：：shared_ptr支持定制删除器 (custom deleter)。</font></div><div><font size="4">可以防范DLL问题，可被用来自动解除互斥锁（见条款14，原书）。</font></div></div>
